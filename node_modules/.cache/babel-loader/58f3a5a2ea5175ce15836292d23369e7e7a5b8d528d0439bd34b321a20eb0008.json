{"ast":null,"code":"import { Material, ShaderMaterial, NoColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { diffuseColor } from '../core/PropertyNode.js';\nimport { materialNormal } from '../accessors/ExtendedMaterialNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsWithoutWrap } from '../lighting/LightsNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nconst NodeMaterials = new Map();\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.name;\n    this.lights = true;\n    this.normals = true;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n  }\n  customProgramCacheKey() {\n    return getCacheKey(this);\n  }\n  build(builder) {\n    this.construct(builder);\n  }\n  construct(builder) {\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.constructPosition(builder);\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    if (this.normals === true) this.constructNormal(builder);\n    this.constructDiffuseColor(builder);\n    this.constructVariants(builder);\n    const outgoingLightNode = this.constructLighting(builder);\n    builder.stack.outputNode = this.constructOutput(builder, outgoingLightNode, diffuseColor.a);\n    builder.addFlow('fragment', builder.removeStack());\n  }\n  constructPosition(builder) {\n    const object = builder.object;\n    let vertex = positionLocal;\n    if (this.positionNode !== null) {\n      vertex = vertex.bypass(positionLocal.assign(this.positionNode));\n    }\n    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      vertex = vertex.bypass(instance(object));\n    }\n    if (object.isSkinnedMesh === true) {\n      vertex = vertex.bypass(skinning(object));\n    }\n    builder.context.vertex = vertex;\n    return modelViewProjection();\n  }\n  constructDiffuseColor(_ref) {\n    let {\n      stack,\n      geometry\n    } = _ref;\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color')), colorNode.a);\n    }\n\n    // COLOR\n\n    stack.assign(diffuseColor, colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    stack.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode ? float(this.alphaTestNode) : materialAlphaTest;\n      stack.add(diffuseColor.a.lessThanEqual(alphaTestNode).discard());\n    }\n  }\n  constructVariants( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  constructNormal(_ref2) {\n    let {\n      stack\n    } = _ref2;\n    // NORMAL VIEW\n\n    const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;\n    stack.assign(transformedNormalView, normalNode);\n    return normalNode;\n  }\n  getEnvNode(builder) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);\n    } else if (builder.environmentNode) {\n      node = builder.environmentNode;\n    }\n    return node;\n  }\n  constructLights(builder) {\n    const envNode = this.getEnvNode(builder);\n\n    //\n\n    const materialLightsNode = [];\n    if (envNode) {\n      materialLightsNode.push(new EnvironmentNode(envNode));\n    }\n    if (builder.material.aoMap) {\n      materialLightsNode.push(new AONode(texture(builder.material.aoMap)));\n    }\n    let lightsNode = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsNode = lightsWithoutWrap([...lightsNode.lightNodes, ...materialLightsNode]);\n    }\n    return lightsNode;\n  }\n  constructLightingModel( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  constructLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.constructLights(builder) : null;\n    const lightingModelNode = lightsNode ? this.constructLightingModel(builder) : null;\n    let outgoingLightNode = diffuseColor.rgb;\n    if (lightsNode && lightsNode.hasLight !== false) {\n      outgoingLightNode = lightsNode.lightingContext(lightingModelNode, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      outgoingLightNode = outgoingLightNode.add(emissiveNode ? vec3(emissiveNode) : materialEmissive);\n    }\n    return outgoingLightNode;\n  }\n  constructOutput(builder, outgoingLight, opacity) {\n    const renderer = builder.renderer;\n\n    // TONE MAPPING\n\n    const toneMappingNode = builder.toneMappingNode;\n    if (toneMappingNode) {\n      outgoingLight = toneMappingNode.context({\n        color: outgoingLight\n      });\n    }\n\n    // @TODO: Optimize outputNode to vec3.\n\n    let outputNode = vec4(outgoingLight, opacity);\n\n    // ENCODING\n\n    const renderTarget = renderer.getRenderTarget();\n    let outputColorSpace;\n    if (renderTarget !== null) {\n      outputColorSpace = renderTarget.texture.colorSpace;\n    } else {\n      outputColorSpace = renderer.outputColorSpace;\n    }\n    if (outputColorSpace !== NoColorSpace) outputNode = outputNode.colorSpace(outputColorSpace);\n\n    // FOG\n\n    const fogNode = builder.fogNode;\n    if (fogNode) outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    Object.assign(this.defines, material.defines);\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  static fromMaterial(material) {\n    if (material.isNodeMaterial === true) {\n      // is already a node material\n\n      return material;\n    }\n    const type = material.type.replace('Material', 'NodeMaterial');\n    const nodeMaterial = createNodeMaterialFromType(type);\n    if (nodeMaterial === undefined) {\n      throw new Error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n    }\n    for (const key in material) {\n      nodeMaterial[key] = material[key];\n    }\n    return nodeMaterial;\n  }\n}\nexport default NodeMaterial;\nexport function addNodeMaterial(nodeMaterial) {\n  if (typeof nodeMaterial !== 'function' || !nodeMaterial.name) throw new Error(`Node material ${nodeMaterial.name} is not a class`);\n  if (NodeMaterials.has(nodeMaterial.name)) throw new Error(`Redefinition of node material ${nodeMaterial.name}`);\n  NodeMaterials.set(nodeMaterial.name, nodeMaterial);\n}\nexport function createNodeMaterialFromType(type) {\n  const Material = NodeMaterials.get(type);\n  if (Material !== undefined) {\n    return new Material();\n  }\n}\naddNodeMaterial(NodeMaterial);","map":{"version":3,"names":["Material","ShaderMaterial","NoColorSpace","getNodeChildren","getCacheKey","attribute","diffuseColor","materialNormal","materialAlphaTest","materialColor","materialOpacity","materialEmissive","modelViewProjection","transformedNormalView","instance","positionLocal","skinning","texture","cubeTexture","lightsWithoutWrap","mix","float","vec3","vec4","AONode","EnvironmentNode","NodeMaterials","Map","NodeMaterial","constructor","isNodeMaterial","type","name","lights","normals","lightsNode","envNode","colorNode","normalNode","opacityNode","backdropNode","backdropAlphaNode","alphaTestNode","positionNode","customProgramCacheKey","build","builder","construct","addStack","stack","outputNode","constructPosition","addFlow","removeStack","constructNormal","constructDiffuseColor","constructVariants","outgoingLightNode","constructLighting","constructOutput","a","object","vertex","bypass","assign","instanceMatrix","isInstancedBufferAttribute","isAvailable","isSkinnedMesh","context","_ref","geometry","vertexColors","hasAttribute","xyz","mul","alphaTest","add","lessThanEqual","discard","_ref2","getEnvNode","node","envMap","isCubeTexture","environmentNode","constructLights","materialLightsNode","push","material","aoMap","length","lightNodes","constructLightingModel","emissiveNode","lightingModelNode","rgb","hasLight","lightingContext","isNode","emissive","isColor","outgoingLight","opacity","renderer","toneMappingNode","color","renderTarget","getRenderTarget","outputColorSpace","colorSpace","fogNode","mixAssign","setDefaultValues","property","value","undefined","clone","Object","defines","descriptors","getOwnPropertyDescriptors","prototype","key","getOwnPropertyDescriptor","get","defineProperty","toJSON","meta","isRoot","textures","images","nodes","data","call","nodeChildren","inputNodes","childNode","uuid","extractFromCache","cache","values","metadata","fromMaterial","replace","nodeMaterial","createNodeMaterialFromType","Error","addNodeMaterial","has","set"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js"],"sourcesContent":["import { Material, ShaderMaterial, NoColorSpace } from 'three';\r\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\r\nimport { attribute } from '../core/AttributeNode.js';\r\nimport { diffuseColor } from '../core/PropertyNode.js';\r\nimport { materialNormal } from '../accessors/ExtendedMaterialNode.js';\r\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive } from '../accessors/MaterialNode.js';\r\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\r\nimport { transformedNormalView } from '../accessors/NormalNode.js';\r\nimport { instance } from '../accessors/InstanceNode.js';\r\nimport { positionLocal } from '../accessors/PositionNode.js';\r\nimport { skinning } from '../accessors/SkinningNode.js';\r\nimport { texture } from '../accessors/TextureNode.js';\r\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\r\nimport { lightsWithoutWrap } from '../lighting/LightsNode.js';\r\nimport { mix } from '../math/MathNode.js';\r\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\r\nimport AONode from '../lighting/AONode.js';\r\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\r\n\r\nconst NodeMaterials = new Map();\r\n\r\nclass NodeMaterial extends ShaderMaterial {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.isNodeMaterial = true;\r\n\r\n\t\tthis.type = this.constructor.name;\r\n\r\n\t\tthis.lights = true;\r\n\t\tthis.normals = true;\r\n\r\n\t\tthis.lightsNode = null;\r\n\t\tthis.envNode = null;\r\n\r\n\t\tthis.colorNode = null;\r\n\t\tthis.normalNode = null;\r\n\t\tthis.opacityNode = null;\r\n\t\tthis.backdropNode = null;\r\n\t\tthis.backdropAlphaNode = null;\r\n\t\tthis.alphaTestNode = null;\r\n\r\n\t\tthis.positionNode = null;\r\n\r\n\t}\r\n\r\n\tcustomProgramCacheKey() {\r\n\r\n\t\treturn getCacheKey( this );\r\n\r\n\t}\r\n\r\n\tbuild( builder ) {\r\n\r\n\t\tthis.construct( builder );\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\t// < VERTEX STAGE >\r\n\r\n\t\tbuilder.addStack();\r\n\r\n\t\tbuilder.stack.outputNode = this.constructPosition( builder );\r\n\r\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\r\n\r\n\t\t// < FRAGMENT STAGE >\r\n\r\n\t\tbuilder.addStack();\r\n\r\n\t\tif ( this.normals === true ) this.constructNormal( builder );\r\n\r\n\t\tthis.constructDiffuseColor( builder );\r\n\t\tthis.constructVariants( builder );\r\n\r\n\t\tconst outgoingLightNode = this.constructLighting( builder );\r\n\r\n\t\tbuilder.stack.outputNode = this.constructOutput( builder, outgoingLightNode, diffuseColor.a );\r\n\r\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\r\n\r\n\t}\r\n\r\n\tconstructPosition( builder ) {\r\n\r\n\t\tconst object = builder.object;\r\n\r\n\t\tlet vertex = positionLocal;\r\n\r\n\t\tif ( this.positionNode !== null ) {\r\n\r\n\t\t\tvertex = vertex.bypass( positionLocal.assign( this.positionNode ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) && builder.isAvailable( 'instance' ) === true ) {\r\n\r\n\t\t\tvertex = vertex.bypass( instance( object ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isSkinnedMesh === true ) {\r\n\r\n\t\t\tvertex = vertex.bypass( skinning( object ) );\r\n\r\n\t\t}\r\n\r\n\t\tbuilder.context.vertex = vertex;\r\n\r\n\t\treturn modelViewProjection();\r\n\r\n\t}\r\n\r\n\tconstructDiffuseColor( { stack, geometry } ) {\r\n\r\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\r\n\r\n\t\t// VERTEX COLORS\r\n\r\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\r\n\r\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color' ) ), colorNode.a );\r\n\r\n\t\t}\r\n\r\n\t\t// COLOR\r\n\r\n\t\tstack.assign( diffuseColor, colorNode );\r\n\r\n\t\t// OPACITY\r\n\r\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\r\n\t\tstack.assign( diffuseColor.a, diffuseColor.a.mul( opacityNode ) );\r\n\r\n\t\t// ALPHA TEST\r\n\r\n\t\tif ( this.alphaTestNode || this.alphaTest > 0 ) {\r\n\r\n\t\t\tconst alphaTestNode = this.alphaTestNode ? float( this.alphaTestNode ) : materialAlphaTest;\r\n\r\n\t\t\tstack.add( diffuseColor.a.lessThanEqual( alphaTestNode ).discard() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconstructVariants( /*builder*/ ) {\r\n\r\n\t\t// Interface function.\r\n\r\n\t}\r\n\r\n\tconstructNormal( { stack } ) {\r\n\r\n\t\t// NORMAL VIEW\r\n\r\n\t\tconst normalNode = this.normalNode ? vec3( this.normalNode ) : materialNormal;\r\n\r\n\t\tstack.assign( transformedNormalView, normalNode );\r\n\r\n\t\treturn normalNode;\r\n\r\n\t}\r\n\r\n\tgetEnvNode( builder ) {\r\n\r\n\t\tlet node = null;\r\n\r\n\t\tif ( this.envNode ) {\r\n\r\n\t\t\tnode = this.envNode;\r\n\r\n\t\t} else if ( this.envMap ) {\r\n\r\n\t\t\tnode = this.envMap.isCubeTexture ? cubeTexture( this.envMap ) : texture( this.envMap );\r\n\r\n\t\t} else if ( builder.environmentNode ) {\r\n\r\n\t\t\tnode = builder.environmentNode;\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tconstructLights( builder ) {\r\n\r\n\t\tconst envNode = this.getEnvNode( builder );\r\n\r\n\t\t//\r\n\r\n\t\tconst materialLightsNode = [];\r\n\r\n\t\tif ( envNode ) {\r\n\r\n\t\t\tmaterialLightsNode.push( new EnvironmentNode( envNode ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( builder.material.aoMap ) {\r\n\r\n\t\t\tmaterialLightsNode.push( new AONode( texture( builder.material.aoMap ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tlet lightsNode = this.lightsNode || builder.lightsNode;\r\n\r\n\t\tif ( materialLightsNode.length > 0 ) {\r\n\r\n\t\t\tlightsNode = lightsWithoutWrap( [ ...lightsNode.lightNodes, ...materialLightsNode ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn lightsNode;\r\n\r\n\t}\r\n\r\n\tconstructLightingModel( /*builder*/ ) {\r\n\r\n\t\t// Interface function.\r\n\r\n\t}\r\n\r\n\tconstructLighting( builder ) {\r\n\r\n\t\tconst { material } = builder;\r\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\r\n\r\n\t\t// OUTGOING LIGHT\r\n\r\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\r\n\r\n\t\tconst lightsNode = lights ? this.constructLights( builder ) : null;\r\n\t\tconst lightingModelNode = lightsNode ? this.constructLightingModel( builder ) : null;\r\n\r\n\t\tlet outgoingLightNode = diffuseColor.rgb;\r\n\r\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) {\r\n\r\n\t\t\toutgoingLightNode = lightsNode.lightingContext( lightingModelNode, backdropNode, backdropAlphaNode );\r\n\r\n\t\t} else if ( backdropNode !== null ) {\r\n\r\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\r\n\r\n\t\t}\r\n\r\n\t\t// EMISSIVE\r\n\r\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\r\n\r\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissiveNode ? vec3( emissiveNode ) : materialEmissive );\r\n\r\n\t\t}\r\n\r\n\t\treturn outgoingLightNode;\r\n\r\n\t}\r\n\r\n\tconstructOutput( builder, outgoingLight, opacity ) {\r\n\r\n\t\tconst renderer = builder.renderer;\r\n\r\n\t\t// TONE MAPPING\r\n\r\n\t\tconst toneMappingNode = builder.toneMappingNode;\r\n\r\n\t\tif ( toneMappingNode ) {\r\n\r\n\t\t\toutgoingLight = toneMappingNode.context( { color: outgoingLight } );\r\n\r\n\t\t}\r\n\r\n\t\t// @TODO: Optimize outputNode to vec3.\r\n\r\n\t\tlet outputNode = vec4( outgoingLight, opacity );\r\n\r\n\t\t// ENCODING\r\n\r\n\t\tconst renderTarget = renderer.getRenderTarget();\r\n\r\n\t\tlet outputColorSpace;\r\n\r\n\t\tif ( renderTarget !== null ) {\r\n\r\n\t\t\toutputColorSpace = renderTarget.texture.colorSpace;\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutputColorSpace = renderer.outputColorSpace;\r\n\r\n\t\t}\r\n\r\n\t\tif ( outputColorSpace !== NoColorSpace ) outputNode = outputNode.colorSpace( outputColorSpace );\r\n\r\n\t\t// FOG\r\n\r\n\t\tconst fogNode = builder.fogNode;\r\n\r\n\t\tif ( fogNode ) outputNode = vec4( fogNode.mixAssign( outputNode.rgb ), outputNode.a );\r\n\r\n\t\treturn outputNode;\r\n\r\n\t}\r\n\r\n\tsetDefaultValues( material ) {\r\n\r\n\t\t// This approach is to reuse the native refreshUniforms*\r\n\t\t// and turn available the use of features like transmission and environment in core\r\n\r\n\t\tfor ( const property in material ) {\r\n\r\n\t\t\tconst value = material[ property ];\r\n\r\n\t\t\tif ( this[ property ] === undefined ) {\r\n\r\n\t\t\t\tthis[ property ] = value;\r\n\r\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tObject.assign( this.defines, material.defines );\r\n\r\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\r\n\r\n\t\tfor ( const key in descriptors ) {\r\n\r\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\r\n\t\t\t     descriptors[ key ].get !== undefined ) {\r\n\r\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoJSON( meta ) {\r\n\r\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\tnodes: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\r\n\t\tconst nodeChildren = getNodeChildren( this );\r\n\r\n\t\tdata.inputNodes = {};\r\n\r\n\t\tfor ( const { property, childNode } of nodeChildren ) {\r\n\r\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\r\n\r\n\t\t}\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tconst values = [];\r\n\r\n\t\t\tfor ( const key in cache ) {\r\n\r\n\t\t\t\tconst data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tconst textures = extractFromCache( meta.textures );\r\n\t\t\tconst images = extractFromCache( meta.images );\r\n\t\t\tconst nodes = extractFromCache( meta.nodes );\r\n\r\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\tif ( images.length > 0 ) data.images = images;\r\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tstatic fromMaterial( material ) {\r\n\r\n\t\tif ( material.isNodeMaterial === true ) { // is already a node material\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t\tconst type = material.type.replace( 'Material', 'NodeMaterial' );\r\n\r\n\t\tconst nodeMaterial = createNodeMaterialFromType( type );\r\n\r\n\t\tif ( nodeMaterial === undefined ) {\r\n\r\n\t\t\tthrow new Error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tnodeMaterial[ key ] = material[ key ];\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeMaterial;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default NodeMaterial;\r\n\r\nexport function addNodeMaterial( nodeMaterial ) {\r\n\r\n\tif ( typeof nodeMaterial !== 'function' || ! nodeMaterial.name ) throw new Error( `Node material ${ nodeMaterial.name } is not a class` );\r\n\tif ( NodeMaterials.has( nodeMaterial.name ) ) throw new Error( `Redefinition of node material ${ nodeMaterial.name }` );\r\n\r\n\tNodeMaterials.set( nodeMaterial.name, nodeMaterial );\r\n\r\n}\r\n\r\nexport function createNodeMaterialFromType( type ) {\r\n\r\n\tconst Material = NodeMaterials.get( type );\r\n\r\n\tif ( Material !== undefined ) {\r\n\r\n\t\treturn new Material();\r\n\r\n\t}\r\n\r\n}\r\n\r\naddNodeMaterial( NodeMaterial );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}