{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec2 } from '../shadernode/ShaderNode.js';\nclass RotateUVNode extends TempNode {\n  constructor(uvNode, rotationNode) {\n    let centerNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : vec2(0.5);\n    super('vec2');\n    this.uvNode = uvNode;\n    this.rotationNode = rotationNode;\n    this.centerNode = centerNode;\n  }\n  construct() {\n    const {\n      uvNode,\n      rotationNode,\n      centerNode\n    } = this;\n    const cosAngle = rotationNode.cos();\n    const sinAngle = rotationNode.sin();\n    const vector = uvNode.sub(centerNode);\n    const rotatedVector = vec2(\n    // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?\n    vec2(cosAngle, sinAngle).dot(vector), vec2(sinAngle.negate(), cosAngle).dot(vector));\n    return rotatedVector.add(centerNode);\n  }\n}\nexport default RotateUVNode;\nexport const rotateUV = nodeProxy(RotateUVNode);\naddNodeElement('rotateUV', rotateUV);\naddNodeClass(RotateUVNode);","map":{"version":3,"names":["TempNode","addNodeClass","addNodeElement","nodeProxy","vec2","RotateUVNode","constructor","uvNode","rotationNode","centerNode","arguments","length","undefined","construct","cosAngle","cos","sinAngle","sin","vector","sub","rotatedVector","dot","negate","add","rotateUV"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\r\nimport { addNodeClass } from '../core/Node.js';\r\nimport { addNodeElement, nodeProxy, vec2 } from '../shadernode/ShaderNode.js';\r\n\r\nclass RotateUVNode extends TempNode {\r\n\r\n\tconstructor( uvNode, rotationNode, centerNode = vec2( 0.5 ) ) {\r\n\r\n\t\tsuper( 'vec2' );\r\n\r\n\t\tthis.uvNode = uvNode;\r\n\t\tthis.rotationNode = rotationNode;\r\n\t\tthis.centerNode = centerNode;\r\n\r\n\t}\r\n\r\n\tconstruct() {\r\n\r\n\t\tconst { uvNode, rotationNode, centerNode } = this;\r\n\r\n\t\tconst cosAngle = rotationNode.cos();\r\n\t\tconst sinAngle = rotationNode.sin();\r\n\r\n\t\tconst vector = uvNode.sub( centerNode );\r\n\r\n\t\tconst rotatedVector = vec2( // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?\r\n\t\t\tvec2( cosAngle, sinAngle ).dot( vector ),\r\n\t\t\tvec2( sinAngle.negate(), cosAngle ).dot( vector )\r\n\t\t);\r\n\r\n\t\treturn rotatedVector.add( centerNode );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default RotateUVNode;\r\n\r\nexport const rotateUV = nodeProxy( RotateUVNode );\r\n\r\naddNodeElement( 'rotateUV', rotateUV );\r\n\r\naddNodeClass( RotateUVNode );\r\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,qBAAqB;AAC1C,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,cAAc,EAAEC,SAAS,EAAEC,IAAI,QAAQ,6BAA6B;AAE7E,MAAMC,YAAY,SAASL,QAAQ,CAAC;EAEnCM,WAAWA,CAAEC,MAAM,EAAEC,YAAY,EAA6B;IAAA,IAA3BC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGN,IAAI,CAAE,GAAI,CAAC;IAE1D,KAAK,CAAE,MAAO,CAAC;IAEf,IAAI,CAACG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,UAAU,GAAGA,UAAU;EAE7B;EAEAI,SAASA,CAAA,EAAG;IAEX,MAAM;MAAEN,MAAM;MAAEC,YAAY;MAAEC;IAAW,CAAC,GAAG,IAAI;IAEjD,MAAMK,QAAQ,GAAGN,YAAY,CAACO,GAAG,CAAC,CAAC;IACnC,MAAMC,QAAQ,GAAGR,YAAY,CAACS,GAAG,CAAC,CAAC;IAEnC,MAAMC,MAAM,GAAGX,MAAM,CAACY,GAAG,CAAEV,UAAW,CAAC;IAEvC,MAAMW,aAAa,GAAGhB,IAAI;IAAE;IAC3BA,IAAI,CAAEU,QAAQ,EAAEE,QAAS,CAAC,CAACK,GAAG,CAAEH,MAAO,CAAC,EACxCd,IAAI,CAAEY,QAAQ,CAACM,MAAM,CAAC,CAAC,EAAER,QAAS,CAAC,CAACO,GAAG,CAAEH,MAAO,CACjD,CAAC;IAED,OAAOE,aAAa,CAACG,GAAG,CAAEd,UAAW,CAAC;EAEvC;AAED;AAEA,eAAeJ,YAAY;AAE3B,OAAO,MAAMmB,QAAQ,GAAGrB,SAAS,CAAEE,YAAa,CAAC;AAEjDH,cAAc,CAAE,UAAU,EAAEsB,QAAS,CAAC;AAEtCvB,YAAY,CAAEI,YAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}