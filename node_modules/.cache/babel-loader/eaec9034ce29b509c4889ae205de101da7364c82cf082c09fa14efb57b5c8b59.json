{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { REVISION, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nconst typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst isNonPaddingElementArray = new Set([Int32Array, Uint32Array, Float32Array]);\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object && (object.material || null);\n    this.geometry = object && (object.geometry || null);\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.toneMappingNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.vars = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.tab = '\\t';\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material,\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode.mul(maxMipLevel(textureNode))\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  getBindings() {\n    let bindingsArray = this.bindingsArray;\n    if (bindingsArray === null) {\n      const bindings = this.bindings;\n      this.bindingsArray = bindingsArray = this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute;\n    }\n    return bindingsArray;\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType();\n      const updateBeforeType = node.getUpdateBeforeType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node);\n      }\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node);\n      }\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  addChain(node) {\n    /*\r\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\r\n    \t\t\tconsole.warn( 'Recursive node: ', node );\r\n    \t\t}\r\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  isAvailable( /*name*/\n  ) {\n    return false;\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  getTexture( /* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  getTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n\n  // @TODO: rename to .generateConst()\n  getConst(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const getConst = value => this.getConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(getConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    return type;\n  }\n  generateMethod(method) {\n    return method;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n  }\n\n  /** @deprecated, r152 */\n  getTextureEncodingFromMap(map) {\n    console.warn('THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.');\n    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  }\n  getTextureColorSpaceFromMap(map) {\n    let colorSpace;\n    if (map && map.isTexture) {\n      colorSpace = map.colorSpace;\n    } else if (map && map.isWebGLRenderTarget) {\n      colorSpace = map.texture.colorSpace;\n    } else {\n      colorSpace = NoColorSpace;\n    }\n    return colorSpace;\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length) {\n    let componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n    if (length === 1) return componentType;\n    const baseType = typeFromLength.get(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const currentStack = this.stack;\n    this.stack = currentStack.parent;\n    return currentStack;\n  }\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const cache = node.isGlobal(this) ? this.globalCache : this.cache;\n    let nodeData = cache.getNodeData(node);\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {},\n        compute: {}\n      };\n      cache.setNodeData(node, nodeData);\n    }\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n  getNodeProperties(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getUniformFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      nodeVarying = new NodeVarying('nodeVarying' + index, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addLineFlowCode(code) {\n    if (code === '') return this;\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${type} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      snippet += `${this.getVar(variable.type, variable.name)}; `;\n    }\n    return snippet;\n  }\n  getUniforms( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    // construct() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n  createNodeMaterial(type) {\n    return createNodeMaterialFromType(type);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","createNodeMaterialFromType","NodeUpdateType","defaultBuildStages","shaderStages","REVISION","NoColorSpace","LinearEncoding","sRGBEncoding","SRGBColorSpace","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","stack","maxMipLevel","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","isNonPaddingElementArray","Set","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","material","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","toneMappingNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","codes","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","vars","flow","code","chaining","tab","context","keywords","getMIPLevelAlgorithmNode","textureNode","levelNode","mul","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","getBindings","setHashNode","node","hash","addNode","indexOf","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","push","getHash","currentNode","length","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getInstanceIndex","console","warn","getFrontFacing","getFragCoord","isFlipY","getTexture","getTextureLevel","getConst","type","arguments","undefined","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","generateMethod","hasGeometryAttribute","name","getAttribute","attribute","getPropertyName","isVector","test","isMatrix","isReference","getTextureEncodingFromMap","getTextureColorSpaceFromMap","colorSpace","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","get","prefix","getTypeFromArray","array","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","has","stride","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","currentStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","set","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","concat","getAttributes","getVaryings","getVar","getVars","snippet","getUniforms","getCodes","getShaderStage","setBuildStage","getBuildStage","buildCode","isNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\r\nimport NodeAttribute from './NodeAttribute.js';\r\nimport NodeVarying from './NodeVarying.js';\r\nimport NodeVar from './NodeVar.js';\r\nimport NodeCode from './NodeCode.js';\r\nimport NodeKeywords from './NodeKeywords.js';\r\nimport NodeCache from './NodeCache.js';\r\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\r\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\r\n\r\nimport { REVISION, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\r\n\r\nimport { stack } from './StackNode.js';\r\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\r\n\r\nconst typeFromLength = new Map( [\r\n\t[ 2, 'vec2' ],\r\n\t[ 3, 'vec3' ],\r\n\t[ 4, 'vec4' ],\r\n\t[ 9, 'mat3' ],\r\n\t[ 16, 'mat4' ]\r\n] );\r\n\r\nconst typeFromArray = new Map( [\r\n\t[ Int8Array, 'int' ],\r\n\t[ Int16Array, 'int' ],\r\n\t[ Int32Array, 'int' ],\r\n\t[ Uint8Array, 'uint' ],\r\n\t[ Uint16Array, 'uint' ],\r\n\t[ Uint32Array, 'uint' ],\r\n\t[ Float32Array, 'float' ]\r\n] );\r\n\r\nconst isNonPaddingElementArray = new Set( [ Int32Array, Uint32Array, Float32Array ] );\r\n\r\nconst toFloat = ( value ) => {\r\n\r\n\tvalue = Number( value );\r\n\r\n\treturn value + ( value % 1 ? '' : '.0' );\r\n\r\n};\r\n\r\nclass NodeBuilder {\r\n\r\n\tconstructor( object, renderer, parser ) {\r\n\r\n\t\tthis.object = object;\r\n\t\tthis.material = object && ( object.material || null );\r\n\t\tthis.geometry = object && ( object.geometry || null );\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.parser = parser;\r\n\r\n\t\tthis.nodes = [];\r\n\t\tthis.updateNodes = [];\r\n\t\tthis.updateBeforeNodes = [];\r\n\t\tthis.hashNodes = {};\r\n\r\n\t\tthis.lightsNode = null;\r\n\t\tthis.environmentNode = null;\r\n\t\tthis.fogNode = null;\r\n\t\tthis.toneMappingNode = null;\r\n\r\n\t\tthis.vertexShader = null;\r\n\t\tthis.fragmentShader = null;\r\n\t\tthis.computeShader = null;\r\n\r\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\r\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\r\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\r\n\t\tthis.bindingsArray = null;\r\n\t\tthis.attributes = [];\r\n\t\tthis.bufferAttributes = [];\r\n\t\tthis.varyings = [];\r\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\r\n\t\tthis.flow = { code: '' };\r\n\t\tthis.chaining = [];\r\n\t\tthis.stack = stack();\r\n\t\tthis.tab = '\\t';\r\n\r\n\t\tthis.context = {\r\n\t\t\tkeywords: new NodeKeywords(),\r\n\t\t\tmaterial: this.material,\r\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode.mul( maxMipLevel( textureNode ) )\r\n\t\t};\r\n\r\n\t\tthis.cache = new NodeCache();\r\n\t\tthis.globalCache = this.cache;\r\n\r\n\t\tthis.flowsData = new WeakMap();\r\n\r\n\t\tthis.shaderStage = null;\r\n\t\tthis.buildStage = null;\r\n\r\n\t}\r\n\r\n\tgetBindings() {\r\n\r\n\t\tlet bindingsArray = this.bindingsArray;\r\n\r\n\t\tif ( bindingsArray === null ) {\r\n\r\n\t\t\tconst bindings = this.bindings;\r\n\r\n\t\t\tthis.bindingsArray = bindingsArray = ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute;\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsArray;\r\n\r\n\t}\r\n\r\n\tsetHashNode( node, hash ) {\r\n\r\n\t\tthis.hashNodes[ hash ] = node;\r\n\r\n\t}\r\n\r\n\taddNode( node ) {\r\n\r\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\r\n\r\n\t\t\tconst updateType = node.getUpdateType();\r\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\r\n\r\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\r\n\r\n\t\t\t\tthis.updateNodes.push( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\r\n\r\n\t\t\t\tthis.updateBeforeNodes.push( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodes.push( node );\r\n\r\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tget currentNode() {\r\n\r\n\t\treturn this.chaining[ this.chaining.length - 1 ];\r\n\r\n\t}\r\n\r\n\taddChain( node ) {\r\n\r\n\t\t/*\r\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\r\n\r\n\t\t\tconsole.warn( 'Recursive node: ', node );\r\n\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\tthis.chaining.push( node );\r\n\r\n\t}\r\n\r\n\tremoveChain( node ) {\r\n\r\n\t\tconst lastChain = this.chaining.pop();\r\n\r\n\t\tif ( lastChain !== node ) {\r\n\r\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetMethod( method ) {\r\n\r\n\t\treturn method;\r\n\r\n\t}\r\n\r\n\tgetNodeFromHash( hash ) {\r\n\r\n\t\treturn this.hashNodes[ hash ];\r\n\r\n\t}\r\n\r\n\taddFlow( shaderStage, node ) {\r\n\r\n\t\tthis.flowNodes[ shaderStage ].push( node );\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tsetContext( context ) {\r\n\r\n\t\tthis.context = context;\r\n\r\n\t}\r\n\r\n\tgetContext() {\r\n\r\n\t\treturn this.context;\r\n\r\n\t}\r\n\r\n\tsetCache( cache ) {\r\n\r\n\t\tthis.cache = cache;\r\n\r\n\t}\r\n\r\n\tgetCache() {\r\n\r\n\t\treturn this.cache;\r\n\r\n\t}\r\n\r\n\tisAvailable( /*name*/ ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tgetInstanceIndex() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetFrontFacing() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetFragCoord() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tisFlipY() {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tgetTexture( /* texture, textureProperty, uvSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\t// @TODO: rename to .generateConst()\r\n\tgetConst( type, value = null ) {\r\n\r\n\t\tif ( value === null ) {\r\n\r\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\r\n\t\t\telse if ( type === 'bool' ) value = false;\r\n\t\t\telse if ( type === 'color' ) value = new Color();\r\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\r\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\r\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\r\n\r\n\t\t}\r\n\r\n\t\tif ( type === 'float' ) return toFloat( value );\r\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\r\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\r\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\r\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\r\n\r\n\t\tconst typeLength = this.getTypeLength( type );\r\n\r\n\t\tconst componentType = this.getComponentType( type );\r\n\r\n\t\tconst getConst = value => this.getConst( componentType, value );\r\n\r\n\t\tif ( typeLength === 2 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\r\n\r\n\t\t} else if ( typeLength === 3 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\r\n\r\n\t\t} else if ( typeLength === 4 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\r\n\r\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( getConst ).join( ', ' ) } )`;\r\n\r\n\t\t} else if ( typeLength > 4 ) {\r\n\r\n\t\t\treturn `${ this.getType( type ) }()`;\r\n\r\n\t\t}\r\n\r\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\r\n\r\n\t}\r\n\r\n\tgetType( type ) {\r\n\r\n\t\treturn type;\r\n\r\n\t}\r\n\r\n\tgenerateMethod( method ) {\r\n\r\n\t\treturn method;\r\n\r\n\t}\r\n\r\n\thasGeometryAttribute( name ) {\r\n\r\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\r\n\r\n\t}\r\n\r\n\tgetAttribute( name, type ) {\r\n\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\t// find attribute\r\n\r\n\t\tfor ( const attribute of attributes ) {\r\n\r\n\t\t\tif ( attribute.name === name ) {\r\n\r\n\t\t\t\treturn attribute;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// create a new if no exist\r\n\r\n\t\tconst attribute = new NodeAttribute( name, type );\r\n\r\n\t\tattributes.push( attribute );\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\tgetPropertyName( node/*, shaderStage*/ ) {\r\n\r\n\t\treturn node.name;\r\n\r\n\t}\r\n\r\n\tisVector( type ) {\r\n\r\n\t\treturn /vec\\d/.test( type );\r\n\r\n\t}\r\n\r\n\tisMatrix( type ) {\r\n\r\n\t\treturn /mat\\d/.test( type );\r\n\r\n\t}\r\n\r\n\tisReference( type ) {\r\n\r\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\r\n\r\n\t}\r\n\r\n\t/** @deprecated, r152 */\r\n\tgetTextureEncodingFromMap( map ) {\r\n\r\n\t\tconsole.warn( 'THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.' );\r\n\t\treturn this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\r\n\r\n\t}\r\n\r\n\tgetTextureColorSpaceFromMap( map ) {\r\n\r\n\t\tlet colorSpace;\r\n\r\n\t\tif ( map && map.isTexture ) {\r\n\r\n\t\t\tcolorSpace = map.colorSpace;\r\n\r\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\r\n\r\n\t\t\tcolorSpace = map.texture.colorSpace;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcolorSpace = NoColorSpace;\r\n\r\n\t\t}\r\n\r\n\t\treturn colorSpace;\r\n\r\n\t}\r\n\r\n\tgetComponentType( type ) {\r\n\r\n\t\ttype = this.getVectorType( type );\r\n\r\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\r\n\r\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\r\n\r\n\t\tif ( componentType === null ) return null;\r\n\r\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\r\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\r\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\r\n\r\n\t\treturn 'float';\r\n\r\n\t}\r\n\r\n\tgetVectorType( type ) {\r\n\r\n\t\tif ( type === 'color' ) return 'vec3';\r\n\t\tif ( type === 'texture' ) return 'vec4';\r\n\r\n\t\treturn type;\r\n\r\n\t}\r\n\r\n\tgetTypeFromLength( length, componentType = 'float' ) {\r\n\r\n\t\tif ( length === 1 ) return componentType;\r\n\r\n\t\tconst baseType = typeFromLength.get( length );\r\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\r\n\r\n\t\treturn prefix + baseType;\r\n\r\n\t}\r\n\r\n\tgetTypeFromArray( array ) {\r\n\r\n\t\treturn typeFromArray.get( array.constructor );\r\n\r\n\t}\r\n\r\n\tgetTypeFromAttribute( attribute ) {\r\n\r\n\t\tlet dataAttribute = attribute;\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\r\n\r\n\t\tconst array = dataAttribute.array;\r\n\t\tconst itemSize = isNonPaddingElementArray.has( array.constructor ) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\r\n\t\tconst normalized = attribute.normalized;\r\n\r\n\t\tlet arrayType;\r\n\r\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\r\n\r\n\t\t\tarrayType = this.getTypeFromArray( array );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\r\n\r\n\t}\r\n\r\n\tgetTypeLength( type ) {\r\n\r\n\t\tconst vecType = this.getVectorType( type );\r\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\r\n\r\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\r\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\r\n\t\tif ( /mat3/.test( type ) === true ) return 9;\r\n\t\tif ( /mat4/.test( type ) === true ) return 16;\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tgetVectorFromMatrix( type ) {\r\n\r\n\t\treturn type.replace( 'mat', 'vec' );\r\n\r\n\t}\r\n\r\n\tchangeComponentType( type, newComponentType ) {\r\n\r\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\r\n\r\n\t}\r\n\r\n\tgetIntegerType( type ) {\r\n\r\n\t\tconst componentType = this.getComponentType( type );\r\n\r\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\r\n\r\n\t\treturn this.changeComponentType( type, 'int' );\r\n\r\n\t}\r\n\r\n\taddStack() {\r\n\r\n\t\tthis.stack = stack( this.stack );\r\n\r\n\t\treturn this.stack;\r\n\r\n\t}\r\n\r\n\tremoveStack() {\r\n\r\n\t\tconst currentStack = this.stack;\r\n\r\n\t\tthis.stack = currentStack.parent;\r\n\r\n\t\treturn currentStack;\r\n\r\n\t}\r\n\r\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst cache = node.isGlobal( this ) ? this.globalCache : this.cache;\r\n\r\n\t\tlet nodeData = cache.getNodeData( node );\r\n\r\n\t\tif ( nodeData === undefined ) {\r\n\r\n\t\t\tnodeData = { vertex: {}, fragment: {}, compute: {} };\r\n\r\n\t\t\tcache.setNodeData( node, nodeData );\r\n\r\n\t\t}\r\n\r\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\r\n\r\n\t}\r\n\r\n\tgetNodeProperties( node, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\r\n\r\n\t}\r\n\r\n\tgetBufferAttributeFromNode( node, type ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node );\r\n\r\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\r\n\r\n\t\tif ( bufferAttribute === undefined ) {\r\n\r\n\t\t\tconst index = this.uniforms.index ++;\r\n\r\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\r\n\r\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\r\n\r\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\r\n\r\n\t\t}\r\n\r\n\t\treturn bufferAttribute;\r\n\r\n\t}\r\n\r\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\tlet nodeUniform = nodeData.uniform;\r\n\r\n\t\tif ( nodeUniform === undefined ) {\r\n\r\n\t\t\tconst index = this.uniforms.index ++;\r\n\r\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\r\n\r\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\r\n\r\n\t\t\tnodeData.uniform = nodeUniform;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeUniform;\r\n\r\n\t}\r\n\r\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\tlet nodeVar = nodeData.variable;\r\n\r\n\t\tif ( nodeVar === undefined ) {\r\n\r\n\t\t\tconst vars = this.vars[ shaderStage ];\r\n\t\t\tconst index = vars.length;\r\n\r\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\r\n\r\n\t\t\tvars.push( nodeVar );\r\n\r\n\t\t\tnodeData.variable = nodeVar;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeVar;\r\n\r\n\t}\r\n\r\n\tgetVaryingFromNode( node, type ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node, null );\r\n\r\n\t\tlet nodeVarying = nodeData.varying;\r\n\r\n\t\tif ( nodeVarying === undefined ) {\r\n\r\n\t\t\tconst varyings = this.varyings;\r\n\t\t\tconst index = varyings.length;\r\n\r\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\r\n\r\n\t\t\tvaryings.push( nodeVarying );\r\n\r\n\t\t\tnodeData.varying = nodeVarying;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeVarying;\r\n\r\n\t}\r\n\r\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst nodeData = this.getDataFromNode( node );\r\n\r\n\t\tlet nodeCode = nodeData.code;\r\n\r\n\t\tif ( nodeCode === undefined ) {\r\n\r\n\t\t\tconst codes = this.codes[ shaderStage ];\r\n\t\t\tconst index = codes.length;\r\n\r\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\r\n\r\n\t\t\tcodes.push( nodeCode );\r\n\r\n\t\t\tnodeData.code = nodeCode;\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeCode;\r\n\r\n\t}\r\n\r\n\taddLineFlowCode( code ) {\r\n\r\n\t\tif ( code === '' ) return this;\r\n\r\n\t\tcode = this.tab + code;\r\n\r\n\t\tif ( ! /;\\s*$/.test( code ) ) {\r\n\r\n\t\t\tcode = code + ';\\n';\r\n\r\n\t\t}\r\n\r\n\t\tthis.flow.code += code;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddFlowCode( code ) {\r\n\r\n\t\tthis.flow.code += code;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddFlowTab() {\r\n\r\n\t\tthis.tab += '\\t';\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tremoveFlowTab() {\r\n\r\n\t\tthis.tab = this.tab.slice( 0, - 1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetFlowData( node/*, shaderStage*/ ) {\r\n\r\n\t\treturn this.flowsData.get( node );\r\n\r\n\t}\r\n\r\n\tflowNode( node ) {\r\n\r\n\t\tconst output = node.getNodeType( this );\r\n\r\n\t\tconst flowData = this.flowChildNode( node, output );\r\n\r\n\t\tthis.flowsData.set( node, flowData );\r\n\r\n\t\treturn flowData;\r\n\r\n\t}\r\n\r\n\tflowChildNode( node, output = null ) {\r\n\r\n\t\tconst previousFlow = this.flow;\r\n\r\n\t\tconst flow = {\r\n\t\t\tcode: '',\r\n\t\t};\r\n\r\n\t\tthis.flow = flow;\r\n\r\n\t\tflow.result = node.build( this, output );\r\n\r\n\t\tthis.flow = previousFlow;\r\n\r\n\t\treturn flow;\r\n\r\n\t}\r\n\r\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\r\n\r\n\t\tconst previousShaderStage = this.shaderStage;\r\n\r\n\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\tconst flowData = this.flowChildNode( node, output );\r\n\r\n\t\tif ( propertyName !== null ) {\r\n\r\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\r\n\r\n\t\t}\r\n\r\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\r\n\r\n\t\tthis.setShaderStage( previousShaderStage );\r\n\r\n\t\treturn flowData;\r\n\r\n\t}\r\n\r\n\tgetAttributesArray() {\r\n\r\n\t\treturn this.attributes.concat( this.bufferAttributes );\r\n\r\n\t}\r\n\r\n\tgetAttributes( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetVaryings( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetVar( type, name ) {\r\n\r\n\t\treturn `${type} ${name}`;\r\n\r\n\t}\r\n\r\n\tgetVars( shaderStage ) {\r\n\r\n\t\tlet snippet = '';\r\n\r\n\t\tconst vars = this.vars[ shaderStage ];\r\n\r\n\t\tfor ( const variable of vars ) {\r\n\r\n\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\r\n\r\n\t\t}\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n\tgetUniforms( /*shaderStage*/ ) {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tgetCodes( shaderStage ) {\r\n\r\n\t\tconst codes = this.codes[ shaderStage ];\r\n\r\n\t\tlet code = '';\r\n\r\n\t\tfor ( const nodeCode of codes ) {\r\n\r\n\t\t\tcode += nodeCode.code + '\\n';\r\n\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\r\n\t}\r\n\r\n\tgetHash() {\r\n\r\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\r\n\r\n\t}\r\n\r\n\tsetShaderStage( shaderStage ) {\r\n\r\n\t\tthis.shaderStage = shaderStage;\r\n\r\n\t}\r\n\r\n\tgetShaderStage() {\r\n\r\n\t\treturn this.shaderStage;\r\n\r\n\t}\r\n\r\n\tsetBuildStage( buildStage ) {\r\n\r\n\t\tthis.buildStage = buildStage;\r\n\r\n\t}\r\n\r\n\tgetBuildStage() {\r\n\r\n\t\treturn this.buildStage;\r\n\r\n\t}\r\n\r\n\tbuildCode() {\r\n\r\n\t\tconsole.warn( 'Abstract function.' );\r\n\r\n\t}\r\n\r\n\tbuild() {\r\n\r\n\t\t// construct() -> stage 1: create possible new nodes and returns an output reference node\r\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\r\n\t\t// generate()  -> stage 3: generate shader\r\n\r\n\t\tfor ( const buildStage of defaultBuildStages ) {\r\n\r\n\t\t\tthis.setBuildStage( buildStage );\r\n\r\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\r\n\r\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( const shaderStage of shaderStages ) {\r\n\r\n\t\t\t\tthis.setShaderStage( shaderStage );\r\n\r\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\r\n\r\n\t\t\t\tfor ( const node of flowNodes ) {\r\n\r\n\t\t\t\t\tif ( buildStage === 'generate' ) {\r\n\r\n\t\t\t\t\t\tthis.flowNode( node );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tnode.build( this );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.setBuildStage( null );\r\n\t\tthis.setShaderStage( null );\r\n\r\n\t\t// stage 4: build code for a specific output\r\n\r\n\t\tthis.buildCode();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcreateNodeMaterial( type ) {\r\n\r\n\t\treturn createNodeMaterialFromType( type );\r\n\r\n\t}\r\n\r\n\tformat( snippet, fromType, toType ) {\r\n\r\n\t\tfromType = this.getVectorType( fromType );\r\n\t\ttoType = this.getVectorType( toType );\r\n\r\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\r\n\t\tconst toTypeLength = this.getTypeLength( toType );\r\n\r\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\r\n\r\n\t\t\t// @TODO: ignore for now\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\r\n\r\n\t\t\t// @TODO: ignore for now\r\n\r\n\t\t\treturn snippet;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength === toTypeLength ) {\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength > toTypeLength ) {\r\n\r\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\r\n\r\n\t\t}\r\n\r\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\r\n\r\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\r\n\r\n\t\t}\r\n\r\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\r\n\r\n\t}\r\n\r\n\tgetSignature() {\r\n\r\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default NodeBuilder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}