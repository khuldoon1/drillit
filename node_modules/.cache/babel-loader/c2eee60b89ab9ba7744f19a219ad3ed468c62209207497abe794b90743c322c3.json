{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\n//import { step } from '../math/MathNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { Color, DepthTexture, NearestFilter } from 'three';\nlet depthMaterial = null;\nclass AnalyticLightNode extends LightingNode {\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.updateType = NodeUpdateType.FRAME;\n    this.light = light;\n    this.rtt = null;\n    this.shadowNode = null;\n    this.color = new Color();\n    this.colorNode = uniform(this.color);\n  }\n  getHash( /*builder*/\n  ) {\n    return this.light.uuid;\n  }\n  constructShadow(builder) {\n    let shadowNode = this.shadowNode;\n    if (shadowNode === null) {\n      if (depthMaterial === null) depthMaterial = builder.createNodeMaterial('MeshBasicNodeMaterial');\n      const shadow = this.light.shadow;\n      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n      const depthTexture = new DepthTexture();\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n      depthTexture.image.width = shadow.mapSize.width;\n      depthTexture.image.height = shadow.mapSize.height;\n      //depthTexture.compareFunction = THREE.LessCompare;\n\n      rtt.depthTexture = depthTexture;\n      shadow.camera.updateProjectionMatrix();\n\n      //\n\n      const bias = reference('bias', 'float', shadow);\n\n      //const diffuseFactor = normalView.dot( objectViewPosition( this.light ).sub( positionView ).normalize().negate() );\n      //bias = mix( bias, 0, diffuseFactor );\n\n      let shadowCoord = uniform(shadow.matrix).mul(positionWorld);\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(), shadowCoord.z);\n\n      // @TODO: Optimize using WebGPU compare-sampler\n\n      let depth = texture(depthTexture, shadowCoord.xy);\n      depth = depth.mul(.5).add(.5).add(bias);\n      shadowNode = cond(shadowCoord.z.lessThan(depth).or(shadowCoord.y.lessThan(.000001) /*@TODO: find the cause and remove it soon */), 1, 0);\n      //shadowNode = step( shadowCoord.z, depth );\n\n      //\n\n      this.rtt = rtt;\n      this.colorNode = this.colorNode.mul(shadowNode);\n      this.shadowNode = shadowNode;\n\n      //\n\n      this.updateBeforeType = NodeUpdateType.RENDER;\n    }\n  }\n  construct(builder) {\n    if (this.light.castShadow) this.constructShadow(builder);\n  }\n  updateShadow(frame) {\n    const {\n      rtt,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    scene.overrideMaterial = depthMaterial;\n    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n    light.shadow.updateMatrices(light);\n    renderer.setRenderTarget(rtt);\n    renderer.render(scene, light.shadow.camera);\n    renderer.setRenderTarget(null);\n    scene.overrideMaterial = null;\n  }\n  updateBefore(frame) {\n    const {\n      light\n    } = this;\n    if (light.castShadow) this.updateShadow(frame);\n  }\n  update( /*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nexport default AnalyticLightNode;\naddNodeClass(AnalyticLightNode);","map":{"version":3,"names":["LightingNode","NodeUpdateType","uniform","addNodeClass","vec3","reference","texture","positionWorld","cond","Color","DepthTexture","NearestFilter","depthMaterial","AnalyticLightNode","constructor","light","arguments","length","undefined","updateType","FRAME","rtt","shadowNode","color","colorNode","getHash","uuid","constructShadow","builder","createNodeMaterial","shadow","getRenderTarget","mapSize","width","height","depthTexture","minFilter","magFilter","image","camera","updateProjectionMatrix","bias","shadowCoord","matrix","mul","xyz","div","w","x","y","oneMinus","z","depth","xy","add","lessThan","or","updateBeforeType","RENDER","construct","castShadow","updateShadow","frame","renderer","scene","overrideMaterial","setSize","updateMatrices","setRenderTarget","render","updateBefore","update","copy","multiplyScalar","intensity"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\nimport { uniform } from '../core/UniformNode.js';\r\nimport { addNodeClass } from '../core/Node.js';\r\nimport { vec3 } from '../shadernode/ShaderNode.js';\r\nimport { reference } from '../accessors/ReferenceNode.js';\r\nimport { texture } from '../accessors/TextureNode.js';\r\nimport { positionWorld } from '../accessors/PositionNode.js';\r\n//import { step } from '../math/MathNode.js';\r\nimport { cond } from '../math/CondNode.js';\r\n\r\nimport { Color, DepthTexture, NearestFilter } from 'three';\r\n\r\nlet depthMaterial = null;\r\n\r\nclass AnalyticLightNode extends LightingNode {\r\n\r\n\tconstructor( light = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.updateType = NodeUpdateType.FRAME;\r\n\r\n\t\tthis.light = light;\r\n\r\n\t\tthis.rtt = null;\r\n\t\tthis.shadowNode = null;\r\n\r\n\t\tthis.color = new Color();\r\n\t\tthis.colorNode = uniform( this.color );\r\n\r\n\t}\r\n\r\n\tgetHash( /*builder*/ ) {\r\n\r\n\t\treturn this.light.uuid;\r\n\r\n\t}\r\n\r\n\tconstructShadow( builder ) {\r\n\r\n\t\tlet shadowNode = this.shadowNode;\r\n\r\n\t\tif ( shadowNode === null ) {\r\n\r\n\t\t\tif ( depthMaterial === null ) depthMaterial = builder.createNodeMaterial( 'MeshBasicNodeMaterial' );\r\n\r\n\t\t\tconst shadow = this.light.shadow;\r\n\t\t\tconst rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\r\n\r\n\t\t\tconst depthTexture = new DepthTexture();\r\n\t\t\tdepthTexture.minFilter = NearestFilter;\r\n\t\t\tdepthTexture.magFilter = NearestFilter;\r\n\t\t\tdepthTexture.image.width = shadow.mapSize.width;\r\n\t\t\tdepthTexture.image.height = shadow.mapSize.height;\r\n\t\t\t//depthTexture.compareFunction = THREE.LessCompare;\r\n\r\n\t\t\trtt.depthTexture = depthTexture;\r\n\r\n\t\t\tshadow.camera.updateProjectionMatrix();\r\n\r\n\t\t\t//\r\n\r\n\t\t\tconst bias = reference( 'bias', 'float', shadow );\r\n\r\n\t\t\t//const diffuseFactor = normalView.dot( objectViewPosition( this.light ).sub( positionView ).normalize().negate() );\r\n\t\t\t//bias = mix( bias, 0, diffuseFactor );\r\n\r\n\t\t\tlet shadowCoord = uniform( shadow.matrix ).mul( positionWorld );\r\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\r\n\r\n\t\t\tshadowCoord = vec3(\r\n\t\t\t\tshadowCoord.x,\r\n\t\t\t\tshadowCoord.y.oneMinus(),\r\n\t\t\t\tshadowCoord.z\r\n\t\t\t);\r\n\r\n\t\t\t// @TODO: Optimize using WebGPU compare-sampler\r\n\r\n\t\t\tlet depth = texture( depthTexture, shadowCoord.xy );\r\n\t\t\tdepth = depth.mul( .5 ).add( .5 ).add( bias );\r\n\r\n\t\t\tshadowNode = cond( shadowCoord.z.lessThan( depth ).or( shadowCoord.y.lessThan( .000001 ) /*@TODO: find the cause and remove it soon */ ), 1, 0 );\r\n\t\t\t//shadowNode = step( shadowCoord.z, depth );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tthis.rtt = rtt;\r\n\t\t\tthis.colorNode = this.colorNode.mul( shadowNode );\r\n\r\n\t\t\tthis.shadowNode = shadowNode;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\tif ( this.light.castShadow ) this.constructShadow( builder );\r\n\r\n\t}\r\n\r\n\tupdateShadow( frame ) {\r\n\r\n\t\tconst { rtt, light } = this;\r\n\t\tconst { renderer, scene } = frame;\r\n\r\n\t\tscene.overrideMaterial = depthMaterial;\r\n\r\n\t\trtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );\r\n\r\n\t\tlight.shadow.updateMatrices( light );\r\n\r\n\t\trenderer.setRenderTarget( rtt );\r\n\t\trenderer.render( scene, light.shadow.camera );\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t\tscene.overrideMaterial = null;\r\n\r\n\t}\r\n\r\n\tupdateBefore( frame ) {\r\n\r\n\t\tconst { light } = this;\r\n\r\n\t\tif ( light.castShadow ) this.updateShadow( frame );\r\n\r\n\t}\r\n\r\n\tupdate( /*frame*/ ) {\r\n\r\n\t\tconst { light } = this;\r\n\r\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default AnalyticLightNode;\r\n\r\naddNodeClass( AnalyticLightNode );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}