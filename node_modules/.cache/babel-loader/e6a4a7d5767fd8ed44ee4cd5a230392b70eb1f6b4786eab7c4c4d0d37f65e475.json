{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { label } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { normalize } from '../math/MathNode.js';\nimport { cameraViewMatrix } from './CameraNode.js';\nimport { modelNormalMatrix } from './ModelNode.js';\nimport { nodeImmutable } from '../shadernode/ShaderNode.js';\nclass NormalNode extends Node {\n  constructor() {\n    let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NormalNode.LOCAL;\n    super('vec3');\n    this.scope = scope;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash( /*builder*/\n  ) {\n    return `normal-${this.scope}`;\n  }\n  generate(builder) {\n    const scope = this.scope;\n    let outputNode = null;\n    if (scope === NormalNode.GEOMETRY) {\n      outputNode = attribute('normal', 'vec3');\n    } else if (scope === NormalNode.LOCAL) {\n      outputNode = varying(normalGeometry);\n    } else if (scope === NormalNode.VIEW) {\n      const vertexNode = modelNormalMatrix.mul(normalLocal);\n      outputNode = normalize(varying(vertexNode));\n    } else if (scope === NormalNode.WORLD) {\n      // To use inverseTransformDirection only inverse the param order like this: cameraViewMatrix.transformDirection( normalView )\n      const vertexNode = normalView.transformDirection(cameraViewMatrix);\n      outputNode = normalize(varying(vertexNode));\n    }\n    return outputNode.build(builder, this.getNodeType(builder));\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n}\nNormalNode.GEOMETRY = 'geometry';\nNormalNode.LOCAL = 'local';\nNormalNode.VIEW = 'view';\nNormalNode.WORLD = 'world';\nexport default NormalNode;\nexport const normalGeometry = nodeImmutable(NormalNode, NormalNode.GEOMETRY);\nexport const normalLocal = nodeImmutable(NormalNode, NormalNode.LOCAL);\nexport const normalView = nodeImmutable(NormalNode, NormalNode.VIEW);\nexport const normalWorld = nodeImmutable(NormalNode, NormalNode.WORLD);\nexport const transformedNormalView = label(normalView, 'TransformedNormalView');\nexport const transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize();\naddNodeClass(NormalNode);","map":{"version":3,"names":["Node","addNodeClass","attribute","label","varying","normalize","cameraViewMatrix","modelNormalMatrix","nodeImmutable","NormalNode","constructor","scope","arguments","length","undefined","LOCAL","isGlobal","getHash","generate","builder","outputNode","GEOMETRY","normalGeometry","VIEW","vertexNode","mul","normalLocal","WORLD","normalView","transformDirection","build","getNodeType","serialize","data","deserialize","normalWorld","transformedNormalView","transformedNormalWorld"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/accessors/NormalNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\r\nimport { attribute } from '../core/AttributeNode.js';\r\nimport { label } from '../core/VarNode.js';\r\nimport { varying } from '../core/VaryingNode.js';\r\nimport { normalize } from '../math/MathNode.js';\r\nimport { cameraViewMatrix } from './CameraNode.js';\r\nimport { modelNormalMatrix } from './ModelNode.js';\r\nimport { nodeImmutable } from '../shadernode/ShaderNode.js';\r\n\r\nclass NormalNode extends Node {\r\n\r\n\tconstructor( scope = NormalNode.LOCAL ) {\r\n\r\n\t\tsuper( 'vec3' );\r\n\r\n\t\tthis.scope = scope;\r\n\r\n\t}\r\n\r\n\tisGlobal() {\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tgetHash( /*builder*/ ) {\r\n\r\n\t\treturn `normal-${this.scope}`;\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst scope = this.scope;\r\n\r\n\t\tlet outputNode = null;\r\n\r\n\t\tif ( scope === NormalNode.GEOMETRY ) {\r\n\r\n\t\t\toutputNode = attribute( 'normal', 'vec3' );\r\n\r\n\t\t} else if ( scope === NormalNode.LOCAL ) {\r\n\r\n\t\t\toutputNode = varying( normalGeometry );\r\n\r\n\t\t} else if ( scope === NormalNode.VIEW ) {\r\n\r\n\t\t\tconst vertexNode = modelNormalMatrix.mul( normalLocal );\r\n\t\t\toutputNode = normalize( varying( vertexNode ) );\r\n\r\n\t\t} else if ( scope === NormalNode.WORLD ) {\r\n\r\n\t\t\t// To use inverseTransformDirection only inverse the param order like this: cameraViewMatrix.transformDirection( normalView )\r\n\t\t\tconst vertexNode = normalView.transformDirection( cameraViewMatrix );\r\n\t\t\toutputNode = normalize( varying( vertexNode ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\r\n\r\n\t}\r\n\r\n\tserialize( data ) {\r\n\r\n\t\tsuper.serialize( data );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\tdeserialize( data ) {\r\n\r\n\t\tsuper.deserialize( data );\r\n\r\n\t\tthis.scope = data.scope;\r\n\r\n\t}\r\n\r\n}\r\n\r\nNormalNode.GEOMETRY = 'geometry';\r\nNormalNode.LOCAL = 'local';\r\nNormalNode.VIEW = 'view';\r\nNormalNode.WORLD = 'world';\r\n\r\nexport default NormalNode;\r\n\r\nexport const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );\r\nexport const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );\r\nexport const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );\r\nexport const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );\r\nexport const transformedNormalView = label( normalView, 'TransformedNormalView' );\r\nexport const transformedNormalWorld = transformedNormalView.transformDirection( cameraViewMatrix ).normalize();\r\n\r\naddNodeClass( NormalNode );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}