{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, ShaderNode, nodeObject, vec4 } from '../shadernode/ShaderNode.js';\nimport { LinearEncoding, LinearSRGBColorSpace, sRGBEncoding, SRGBColorSpace } from 'three';\nexport const LinearToLinear = new ShaderNode(inputs => {\n  return inputs.value;\n});\nexport const LinearTosRGB = new ShaderNode(inputs => {\n  const {\n    value\n  } = inputs;\n  const {\n    rgb\n  } = value;\n  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);\n  const b = rgb.mul(12.92);\n  const factor = rgb.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return vec4(rgbResult, value.a);\n});\nconst EncodingLib = {\n  LinearToLinear,\n  LinearTosRGB\n};\nclass ColorSpaceNode extends TempNode {\n  constructor(method, node) {\n    super('vec4');\n    this.method = method;\n    this.node = node;\n  }\n  fromColorSpace(colorSpace) {\n    let method = null;\n    if (colorSpace === LinearSRGBColorSpace) {\n      method = 'Linear';\n    } else if (colorSpace === SRGBColorSpace) {\n      method = 'sRGB';\n    }\n    this.method = 'LinearTo' + method;\n    return this;\n  }\n  fromEncoding(encoding) {\n    // @deprecated, r152\n\n    console.warn('THREE.ColorSpaceNode: Method .fromEncoding renamed to .fromColorSpace.');\n    let method = null;\n    if (encoding === LinearEncoding) {\n      method = 'Linear';\n    } else if (encoding === sRGBEncoding) {\n      method = 'sRGB';\n    }\n    this.method = 'LinearTo' + method;\n    return this;\n  }\n  construct() {\n    const {\n      method,\n      node\n    } = this;\n    return EncodingLib[method].call({\n      value: node\n    });\n  }\n}\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nexport default ColorSpaceNode;\nexport const colorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(null, nodeObject(node)).fromColorSpace(colorSpace));\naddNodeElement('colorSpace', colorSpace);\naddNodeClass(ColorSpaceNode);","map":{"version":3,"names":["TempNode","mix","addNodeClass","addNodeElement","ShaderNode","nodeObject","vec4","LinearEncoding","LinearSRGBColorSpace","sRGBEncoding","SRGBColorSpace","LinearToLinear","inputs","value","LinearTosRGB","rgb","a","pow","mul","sub","b","factor","lessThanEqual","rgbResult","EncodingLib","ColorSpaceNode","constructor","method","node","fromColorSpace","colorSpace","fromEncoding","encoding","console","warn","construct","call","LINEAR_TO_LINEAR","LINEAR_TO_SRGB"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\r\nimport { mix } from '../math/MathNode.js';\r\nimport { addNodeClass } from '../core/Node.js';\r\nimport { addNodeElement, ShaderNode, nodeObject, vec4 } from '../shadernode/ShaderNode.js';\r\n\r\nimport { LinearEncoding, LinearSRGBColorSpace, sRGBEncoding, SRGBColorSpace } from 'three';\r\n\r\nexport const LinearToLinear = new ShaderNode( ( inputs ) => {\r\n\r\n\treturn inputs.value;\r\n\r\n} );\r\n\r\nexport const LinearTosRGB = new ShaderNode( ( inputs ) => {\r\n\r\n\tconst { value } = inputs;\r\n\tconst { rgb } = value;\r\n\r\n\tconst a = rgb.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\r\n\tconst b = rgb.mul( 12.92 );\r\n\tconst factor = rgb.lessThanEqual( 0.0031308 );\r\n\r\n\tconst rgbResult = mix( a, b, factor );\r\n\r\n\treturn vec4( rgbResult, value.a );\r\n\r\n} );\r\n\r\nconst EncodingLib = {\r\n\tLinearToLinear,\r\n\tLinearTosRGB\r\n};\r\n\r\nclass ColorSpaceNode extends TempNode {\r\n\r\n\tconstructor( method, node ) {\r\n\r\n\t\tsuper( 'vec4' );\r\n\r\n\t\tthis.method = method;\r\n\r\n\t\tthis.node = node;\r\n\r\n\t}\r\n\r\n\tfromColorSpace( colorSpace ) {\r\n\r\n\t\tlet method = null;\r\n\r\n\t\tif ( colorSpace === LinearSRGBColorSpace ) {\r\n\r\n\t\t\tmethod = 'Linear';\r\n\r\n\t\t} else if ( colorSpace === SRGBColorSpace ) {\r\n\r\n\t\t\tmethod = 'sRGB';\r\n\r\n\t\t}\r\n\r\n\t\tthis.method = 'LinearTo' + method;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tfromEncoding( encoding ) { // @deprecated, r152\r\n\r\n\t\tconsole.warn( 'THREE.ColorSpaceNode: Method .fromEncoding renamed to .fromColorSpace.' );\r\n\r\n\t\tlet method = null;\r\n\r\n\t\tif ( encoding === LinearEncoding ) {\r\n\r\n\t\t\tmethod = 'Linear';\r\n\r\n\t\t} else if ( encoding === sRGBEncoding ) {\r\n\r\n\t\t\tmethod = 'sRGB';\r\n\r\n\t\t}\r\n\r\n\t\tthis.method = 'LinearTo' + method;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tconstruct() {\r\n\r\n\t\tconst { method, node } = this;\r\n\r\n\t\treturn EncodingLib[ method ].call( { value: node } );\r\n\r\n\t}\r\n\r\n}\r\n\r\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\r\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\r\n\r\nexport default ColorSpaceNode;\r\n\r\nexport const colorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( null, nodeObject( node ) ).fromColorSpace( colorSpace ) );\r\n\r\naddNodeElement( 'colorSpace', colorSpace );\r\n\r\naddNodeClass( ColorSpaceNode );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}