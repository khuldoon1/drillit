{"ast":null,"code":"import UniformsGroup from '../../common/UniformsGroup.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../common/nodes/NodeUniform.js';\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\nimport UniformBuffer from '../../common/UniformBuffer.js';\nimport StorageBuffer from '../../common/StorageBuffer.js';\nimport { getVectorLength, getStrideLength } from '../../common/BufferUtils.js';\nimport RenderTarget from '../../common/RenderTarget.js';\nimport CubeRenderTarget from '../../common/CubeRenderTarget.js';\nimport { NodeBuilder, CodeNode, NodeMaterial } from '../../../nodes/Nodes.js';\nimport WGSLNodeParser from './WGSLNodeParser.js';\n\n/*\r\nconst gpuShaderStageLib = {\r\n\t'vertex': GPUShaderStage.VERTEX,\r\n\t'fragment': GPUShaderStage.FRAGMENT,\r\n\t'compute': GPUShaderStage.COMPUTE\r\n};\r\n*/\n\nconst supports = {\n  instance: true\n};\nconst wgslTypeLib = {\n  float: 'f32',\n  int: 'i32',\n  uint: 'u32',\n  bool: 'bool',\n  color: 'vec3<f32>',\n  vec2: 'vec2<f32>',\n  ivec2: 'vec2<i32>',\n  uvec2: 'vec2<u32>',\n  bvec2: 'vec2<bool>',\n  vec3: 'vec3<f32>',\n  ivec3: 'vec3<i32>',\n  uvec3: 'vec3<u32>',\n  bvec3: 'vec3<bool>',\n  vec4: 'vec4<f32>',\n  ivec4: 'vec4<i32>',\n  uvec4: 'vec4<u32>',\n  bvec4: 'vec4<bool>',\n  mat3: 'mat3x3<f32>',\n  imat3: 'mat3x3<i32>',\n  umat3: 'mat3x3<u32>',\n  bmat3: 'mat3x3<bool>',\n  mat4: 'mat4x4<f32>',\n  imat4: 'mat4x4<i32>',\n  umat4: 'mat4x4<u32>',\n  bmat4: 'mat4x4<bool>'\n};\nconst wgslMethods = {\n  dFdx: 'dpdx',\n  dFdy: 'dpdy',\n  mod: 'threejs_mod',\n  lessThanEqual: 'threejs_lessThanEqual',\n  inversesqrt: 'inverseSqrt'\n};\nconst wgslPolyfill = {\n  lessThanEqual: new CodeNode(`\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n`),\n  mod: new CodeNode(`\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n`),\n  repeatWrapping: new CodeNode(`\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n`)\n};\nclass WebGPUNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new WGSLNodeParser());\n    this.uniformsGroup = {};\n    this.builtins = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map(),\n      attribute: new Map()\n    };\n  }\n  build() {\n    const {\n      object,\n      material\n    } = this;\n    if (material !== null) {\n      NodeMaterial.fromMaterial(material).build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n    return super.build();\n  }\n  getSampler(textureProperty, uvSnippet) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n    } else {\n      this._include('repeatWrapping');\n      const dimension = `textureDimensions( ${textureProperty}, 0 )`;\n      return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), 0 )`;\n    }\n  }\n  getVideoSampler(textureProperty, uvSnippet) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);\n    }\n  }\n  getSamplerLevel(textureProperty, uvSnippet, biasSnippet) {\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n      this._include('repeatWrapping');\n      const dimension = `textureDimensions( ${textureProperty}, 0 )`;\n      return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;\n    }\n  }\n  getTexture(texture, textureProperty, uvSnippet) {\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this.getVideoSampler(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this.getSampler(textureProperty, uvSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  getTextureLevel(texture, textureProperty, uvSnippet, biasSnippet) {\n    let shaderStage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.shaderStage;\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this.getVideoSampler(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this.getSamplerLevel(textureProperty, uvSnippet, biasSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  getPropertyName(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    if (node.isNodeVarying === true && node.needsInterpolation === true) {\n      if (shaderStage === 'vertex') {\n        return `NodeVaryings.${node.name}`;\n      }\n    } else if (node.isNodeUniform === true) {\n      const name = node.name;\n      const type = node.type;\n      if (type === 'texture' || type === 'cubeTexture') {\n        return name;\n      } else if (type === 'buffer' || type === 'storageBuffer') {\n        return `NodeBuffer_${node.node.id}.${name}`;\n      } else {\n        return `NodeUniforms.${name}`;\n      }\n    }\n    return super.getPropertyName(node);\n  }\n  getUniformFromNode(node, type, shaderStage) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage);\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.uniformGPU === undefined) {\n      let uniformGPU;\n      const bindings = this.bindings[shaderStage];\n      if (type === 'texture' || type === 'cubeTexture') {\n        const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node);\n        let texture = null;\n        if (type === 'texture') {\n          texture = new NodeSampledTexture(uniformNode.name, uniformNode.node);\n        } else if (type === 'cubeTexture') {\n          texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);\n        }\n\n        // add first textures in sequence and group for last\n        const lastBinding = bindings[bindings.length - 1];\n        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n        if (shaderStage === 'fragment') {\n          bindings.splice(index, 0, sampler, texture);\n          uniformGPU = [sampler, texture];\n        } else {\n          bindings.splice(index, 0, texture);\n          uniformGPU = [texture];\n        }\n      } else if (type === 'buffer' || type === 'storageBuffer') {\n        const bufferClass = type === 'storageBuffer' ? StorageBuffer : UniformBuffer;\n        const buffer = new bufferClass('NodeBuffer_' + node.id, node.value);\n        //buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n        // add first textures in sequence and group for last\n        const lastBinding = bindings[bindings.length - 1];\n        const index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\n        bindings.splice(index, 0, buffer);\n        uniformGPU = buffer;\n      } else {\n        let uniformsGroup = this.uniformsGroup[shaderStage];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new UniformsGroup('nodeUniforms');\n          //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n          this.uniformsGroup[shaderStage] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        if (node.isArrayUniformNode === true) {\n          uniformGPU = [];\n          for (const uniformNode of node.nodes) {\n            const uniformNodeGPU = this._getNodeUniform(uniformNode, type);\n\n            // fit bounds to buffer\n            uniformNodeGPU.boundary = getVectorLength(uniformNodeGPU.itemSize);\n            uniformNodeGPU.itemSize = getStrideLength(uniformNodeGPU.itemSize);\n            uniformsGroup.addUniform(uniformNodeGPU);\n            uniformGPU.push(uniformNodeGPU);\n          }\n        } else {\n          uniformGPU = this._getNodeUniform(uniformNode, type);\n          uniformsGroup.addUniform(uniformGPU);\n        }\n      }\n      nodeData.uniformGPU = uniformGPU;\n      if (shaderStage === 'vertex') {\n        this.bindingsOffset['fragment'] = bindings.length;\n      }\n    }\n    return uniformNode;\n  }\n  isReference(type) {\n    return super.isReference(type) || type === 'texture_2d' || type === 'texture_cube';\n  }\n  getBuiltin(name, property, type) {\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    const map = this.builtins[shaderStage];\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        property,\n        type\n      });\n    }\n    return property;\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');\n    }\n    return 'instanceIndex';\n  }\n  getFrontFacing() {\n    return this.getBuiltin('front_facing', 'isFront', 'bool');\n  }\n  getFragCoord() {\n    return this.getBuiltin('position', 'fragCoord', 'vec4<f32>', 'fragment');\n  }\n  isFlipY() {\n    return false;\n  }\n  getAttributes(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'compute') {\n      this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      for (const {\n        name,\n        property,\n        type\n      } of this.builtins.attribute.values()) {\n        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n      }\n      const attributes = this.getAttributesArray();\n      for (let index = 0, length = attributes.length; index < length; index++) {\n        const attribute = attributes[index];\n        const name = attribute.name;\n        const type = this.getType(attribute.type);\n        snippets.push(`@location( ${index} ) ${name} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getVar(type, name) {\n    return `var ${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    for (const variable of vars) {\n      snippets.push(`\\t${this.getVar(variable.type, variable.name)};`);\n    }\n    return `\\n${snippets.join('\\n')}\\n`;\n  }\n  getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'fragment') {\n      const varyings = this.varyings;\n      const vars = this.vars[shaderStage];\n      for (let index = 0; index < varyings.length; index++) {\n        const varying = varyings[index];\n        if (varying.needsInterpolation) {\n          let attributesSnippet = `@location( ${index} )`;\n          if (varying.type === 'int' || varying.type === 'uint') {\n            attributesSnippet += ' @interpolate( flat )';\n          }\n          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);\n        } else if (vars.includes(varying) === false) {\n          vars.push(varying);\n        }\n      }\n    }\n    for (const {\n      name,\n      property,\n      type\n    } of this.builtins[shaderStage].values()) {\n      snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n    }\n    const code = snippets.join(',\\n\\t');\n    return shaderStage === 'vertex' ? this._getWGSLStruct('NodeVaryingsStruct', '\\t' + code) : code;\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const bufferSnippets = [];\n    const groupSnippets = [];\n    let index = this.bindingsOffset[shaderStage];\n    for (const uniform of uniforms) {\n      if (uniform.type === 'texture' || uniform.type === 'cubeTexture') {\n        if (shaderStage === 'fragment') {\n          bindingSnippets.push(`@group( 0 ) @binding( ${index++} ) var ${uniform.name}_sampler : sampler;`);\n        }\n        const texture = uniform.node.value;\n        let textureType;\n        if (texture.isCubeTexture === true) {\n          textureType = 'texture_cube<f32>';\n        } else if (texture.isDepthTexture === true) {\n          textureType = 'texture_depth_2d';\n        } else if (texture.isVideoTexture === true) {\n          textureType = 'texture_external';\n        } else {\n          textureType = 'texture_2d<f32>';\n        }\n        bindingSnippets.push(`@group( 0 ) @binding( ${index++} ) var ${uniform.name} : ${textureType};`);\n      } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';\n        const bufferSnippet = `\\t${uniform.name} : array< ${bufferType}${bufferCountSnippet} >\\n`;\n        const bufferAccessMode = bufferNode.isStorageBufferNode ? 'storage,read_write' : 'uniform';\n        bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, index++));\n      } else {\n        const vectorType = this.getType(this.getVectorType(uniform.type));\n        if (Array.isArray(uniform.value) === true) {\n          const length = uniform.value.length;\n          groupSnippets.push(`uniform ${vectorType}[ ${length} ] ${uniform.name}`);\n        } else {\n          groupSnippets.push(`\\t${uniform.name} : ${vectorType}`);\n        }\n      }\n    }\n    let code = bindingSnippets.join('\\n');\n    code += bufferSnippets.join('\\n');\n    if (groupSnippets.length > 0) {\n      code += this._getWGSLStructBinding('NodeUniforms', groupSnippets.join(',\\n'), 'uniform', index++);\n    }\n    return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'NodeVaryings.Vertex = ';\n          } else if (shaderStage === 'fragment') {\n            flow += 'return ';\n          }\n          flow += `${flowSlotData.result};`;\n        }\n      }\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));\n    }\n  }\n  getRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  getCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  getMethod(method) {\n    if (wgslPolyfill[method] !== undefined) {\n      this._include(method);\n    }\n    return wgslMethods[method] || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] || type;\n  }\n  isAvailable(name) {\n    return supports[name] === true;\n  }\n  _include(name) {\n    wgslPolyfill[name].build(this);\n  }\n  _getNodeUniform(uniformNode, type) {\n    if (type === 'float') return new FloatNodeUniform(uniformNode);\n    if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  _getWGSLVertexCode(shaderData) {\n    return `${this.getSignature()}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {\n\n\t// system\n\tvar NodeVaryings: NodeVaryingsStruct;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn NodeVaryings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return `${this.getSignature()}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> @location( 0 ) vec4<f32> {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, workgroupSize) {\n    return `${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, vars, access) {\n    let binding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let group = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const structName = name + 'Struct';\n    const structSnippet = this._getWGSLStruct(structName, vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n  }\n}\nexport default WebGPUNodeBuilder;","map":{"version":3,"names":["UniformsGroup","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","NodeSampler","NodeSampledTexture","NodeSampledCubeTexture","UniformBuffer","StorageBuffer","getVectorLength","getStrideLength","RenderTarget","CubeRenderTarget","NodeBuilder","CodeNode","NodeMaterial","WGSLNodeParser","supports","instance","wgslTypeLib","float","int","uint","bool","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","wgslMethods","dFdx","dFdy","mod","lessThanEqual","inversesqrt","wgslPolyfill","repeatWrapping","WebGPUNodeBuilder","constructor","object","renderer","uniformsGroup","builtins","vertex","Map","fragment","compute","attribute","build","material","fromMaterial","addFlow","getSampler","textureProperty","uvSnippet","shaderStage","arguments","length","undefined","_include","dimension","getVideoSampler","console","error","getSamplerLevel","biasSnippet","getTexture","texture","snippet","isVideoTexture","getTextureLevel","getPropertyName","node","isNodeVarying","needsInterpolation","name","isNodeUniform","type","id","getUniformFromNode","uniformNode","nodeData","getDataFromNode","uniformGPU","bindings","sampler","lastBinding","index","isUniformsGroup","splice","bufferClass","buffer","value","push","isArrayUniformNode","nodes","uniformNodeGPU","_getNodeUniform","boundary","itemSize","addUniform","bindingsOffset","isReference","getBuiltin","property","map","has","set","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","getAttributes","snippets","values","attributes","getAttributesArray","getType","join","getVar","getVars","vars","variable","getVaryings","varyings","varying","attributesSnippet","includes","code","_getWGSLStruct","getUniforms","uniforms","bindingSnippets","bufferSnippets","groupSnippets","uniform","textureType","isCubeTexture","isDepthTexture","bufferNode","bufferType","bufferCount","bufferCountSnippet","bufferSnippet","bufferAccessMode","isStorageBufferNode","_getWGSLStructBinding","vectorType","getVectorType","Array","isArray","buildCode","shadersData","flow","flowCode","flowNodes","mainNode","flowSlotData","getFlowData","slotName","result","stageData","codes","getCodes","vertexShader","_getWGSLVertexCode","fragmentShader","_getWGSLFragmentCode","computeShader","_getWGSLComputeCode","workgroupSize","getRenderTarget","width","height","options","getCubeRenderTarget","size","getMethod","method","isAvailable","Error","shaderData","getSignature","access","binding","group","structName","structSnippet"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeBuilder.js"],"sourcesContent":["import UniformsGroup from '../../common/UniformsGroup.js';\r\nimport {\r\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\r\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\r\n} from '../../common/nodes/NodeUniform.js';\r\nimport NodeSampler from '../../common/nodes/NodeSampler.js';\r\nimport { NodeSampledTexture, NodeSampledCubeTexture } from '../../common/nodes/NodeSampledTexture.js';\r\n\r\nimport UniformBuffer from '../../common/UniformBuffer.js';\r\nimport StorageBuffer from '../../common/StorageBuffer.js';\r\nimport { getVectorLength, getStrideLength } from '../../common/BufferUtils.js';\r\n\r\nimport RenderTarget from '../../common/RenderTarget.js';\r\nimport CubeRenderTarget from '../../common/CubeRenderTarget.js';\r\n\r\nimport { NodeBuilder, CodeNode, NodeMaterial } from '../../../nodes/Nodes.js';\r\n\r\nimport WGSLNodeParser from './WGSLNodeParser.js';\r\n\r\n/*\r\nconst gpuShaderStageLib = {\r\n\t'vertex': GPUShaderStage.VERTEX,\r\n\t'fragment': GPUShaderStage.FRAGMENT,\r\n\t'compute': GPUShaderStage.COMPUTE\r\n};\r\n*/\r\n\r\nconst supports = {\r\n\tinstance: true\r\n};\r\n\r\nconst wgslTypeLib = {\r\n\tfloat: 'f32',\r\n\tint: 'i32',\r\n\tuint: 'u32',\r\n\tbool: 'bool',\r\n\tcolor: 'vec3<f32>',\r\n\r\n\tvec2: 'vec2<f32>',\r\n\tivec2: 'vec2<i32>',\r\n\tuvec2: 'vec2<u32>',\r\n\tbvec2: 'vec2<bool>',\r\n\r\n\tvec3: 'vec3<f32>',\r\n\tivec3: 'vec3<i32>',\r\n\tuvec3: 'vec3<u32>',\r\n\tbvec3: 'vec3<bool>',\r\n\r\n\tvec4: 'vec4<f32>',\r\n\tivec4: 'vec4<i32>',\r\n\tuvec4: 'vec4<u32>',\r\n\tbvec4: 'vec4<bool>',\r\n\r\n\tmat3: 'mat3x3<f32>',\r\n\timat3: 'mat3x3<i32>',\r\n\tumat3: 'mat3x3<u32>',\r\n\tbmat3: 'mat3x3<bool>',\r\n\r\n\tmat4: 'mat4x4<f32>',\r\n\timat4: 'mat4x4<i32>',\r\n\tumat4: 'mat4x4<u32>',\r\n\tbmat4: 'mat4x4<bool>'\r\n};\r\n\r\nconst wgslMethods = {\r\n\tdFdx: 'dpdx',\r\n\tdFdy: 'dpdy',\r\n\tmod: 'threejs_mod',\r\n\tlessThanEqual: 'threejs_lessThanEqual',\r\n\tinversesqrt: 'inverseSqrt'\r\n};\r\n\r\nconst wgslPolyfill = {\r\n\tlessThanEqual: new CodeNode( `\r\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\r\n\r\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\r\n\r\n}\r\n` ),\r\n\tmod: new CodeNode( `\r\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\r\n\r\n\treturn x - y * floor( x / y );\r\n\r\n}\r\n` ),\r\n\trepeatWrapping: new CodeNode( `\r\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\r\n\r\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\r\n\r\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\r\n\r\n}\r\n` )\r\n};\r\n\r\nclass WebGPUNodeBuilder extends NodeBuilder {\r\n\r\n\tconstructor( object, renderer ) {\r\n\r\n\t\tsuper( object, renderer, new WGSLNodeParser() );\r\n\r\n\t\tthis.uniformsGroup = {};\r\n\r\n\t\tthis.builtins = {\r\n\t\t\tvertex: new Map(),\r\n\t\t\tfragment: new Map(),\r\n\t\t\tcompute: new Map(),\r\n\t\t\tattribute: new Map()\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tbuild() {\r\n\r\n\t\tconst { object, material } = this;\r\n\r\n\t\tif ( material !== null ) {\r\n\r\n\t\t\tNodeMaterial.fromMaterial( material ).build( this );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.addFlow( 'compute', object );\r\n\r\n\t\t}\r\n\r\n\t\treturn super.build();\r\n\r\n\t}\r\n\r\n\tgetSampler( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\r\n\r\n\t\tif ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\treturn `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._include( 'repeatWrapping' );\r\n\r\n\t\t\tconst dimension = `textureDimensions( ${textureProperty}, 0 )`;\r\n\r\n\t\t\treturn `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), 0 )`;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetVideoSampler( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\r\n\r\n\t\tif ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\treturn `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetSamplerLevel( textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {\r\n\r\n\t\tif ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\treturn `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._include( 'repeatWrapping' );\r\n\r\n\t\t\tconst dimension = `textureDimensions( ${textureProperty}, 0 )`;\r\n\r\n\t\t\treturn `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${biasSnippet} ) )`;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetTexture( texture, textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\r\n\r\n\t\tlet snippet = null;\r\n\r\n\t\tif ( texture.isVideoTexture === true ) {\r\n\r\n\t\t\tsnippet = this.getVideoSampler( textureProperty, uvSnippet, shaderStage );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsnippet = this.getSampler( textureProperty, uvSnippet, shaderStage );\r\n\r\n\t\t}\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n\tgetTextureLevel( texture, textureProperty, uvSnippet, biasSnippet, shaderStage = this.shaderStage ) {\r\n\r\n\t\tlet snippet = null;\r\n\r\n\t\tif ( texture.isVideoTexture === true ) {\r\n\r\n\t\t\tsnippet = this.getVideoSampler( textureProperty, uvSnippet, shaderStage );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsnippet = this.getSamplerLevel( textureProperty, uvSnippet, biasSnippet, shaderStage );\r\n\r\n\t\t}\r\n\r\n\t\treturn snippet;\r\n\r\n\t}\r\n\r\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\r\n\r\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\r\n\r\n\t\t\tif ( shaderStage === 'vertex' ) {\r\n\r\n\t\t\t\treturn `NodeVaryings.${ node.name }`;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( node.isNodeUniform === true ) {\r\n\r\n\t\t\tconst name = node.name;\r\n\t\t\tconst type = node.type;\r\n\r\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' ) {\r\n\r\n\t\t\t\treturn name;\r\n\r\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' ) {\r\n\r\n\t\t\t\treturn `NodeBuffer_${node.node.id}.${name}`;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn `NodeUniforms.${name}`;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn super.getPropertyName( node );\r\n\r\n\t}\r\n\r\n\tgetUniformFromNode( node, type, shaderStage ) {\r\n\r\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage );\r\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\r\n\r\n\t\tif ( nodeData.uniformGPU === undefined ) {\r\n\r\n\t\t\tlet uniformGPU;\r\n\r\n\t\t\tconst bindings = this.bindings[ shaderStage ];\r\n\r\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' ) {\r\n\r\n\t\t\t\tconst sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node );\r\n\r\n\t\t\t\tlet texture = null;\r\n\r\n\t\t\t\tif ( type === 'texture' ) {\r\n\r\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node );\r\n\r\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\r\n\r\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add first textures in sequence and group for last\r\n\t\t\t\tconst lastBinding = bindings[ bindings.length - 1 ];\r\n\t\t\t\tconst index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\r\n\r\n\t\t\t\tif ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\t\t\tbindings.splice( index, 0, sampler, texture );\r\n\r\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbindings.splice( index, 0, texture );\r\n\r\n\t\t\t\t\tuniformGPU = [ texture ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' ) {\r\n\r\n\t\t\t\tconst bufferClass = type === 'storageBuffer' ? StorageBuffer : UniformBuffer;\r\n\t\t\t\tconst buffer = new bufferClass( 'NodeBuffer_' + node.id, node.value );\r\n\t\t\t\t//buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\r\n\r\n\t\t\t\t// add first textures in sequence and group for last\r\n\t\t\t\tconst lastBinding = bindings[ bindings.length - 1 ];\r\n\t\t\t\tconst index = lastBinding && lastBinding.isUniformsGroup ? bindings.length - 1 : bindings.length;\r\n\r\n\t\t\t\tbindings.splice( index, 0, buffer );\r\n\r\n\t\t\t\tuniformGPU = buffer;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet uniformsGroup = this.uniformsGroup[ shaderStage ];\r\n\r\n\t\t\t\tif ( uniformsGroup === undefined ) {\r\n\r\n\t\t\t\t\tuniformsGroup = new UniformsGroup( 'nodeUniforms' );\r\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\r\n\r\n\t\t\t\t\tthis.uniformsGroup[ shaderStage ] = uniformsGroup;\r\n\r\n\t\t\t\t\tbindings.push( uniformsGroup );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( node.isArrayUniformNode === true ) {\r\n\r\n\t\t\t\t\tuniformGPU = [];\r\n\r\n\t\t\t\t\tfor ( const uniformNode of node.nodes ) {\r\n\r\n\t\t\t\t\t\tconst uniformNodeGPU = this._getNodeUniform( uniformNode, type );\r\n\r\n\t\t\t\t\t\t// fit bounds to buffer\r\n\t\t\t\t\t\tuniformNodeGPU.boundary = getVectorLength( uniformNodeGPU.itemSize );\r\n\t\t\t\t\t\tuniformNodeGPU.itemSize = getStrideLength( uniformNodeGPU.itemSize );\r\n\r\n\t\t\t\t\t\tuniformsGroup.addUniform( uniformNodeGPU );\r\n\r\n\t\t\t\t\t\tuniformGPU.push( uniformNodeGPU );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniformGPU = this._getNodeUniform( uniformNode, type );\r\n\r\n\t\t\t\t\tuniformsGroup.addUniform( uniformGPU );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnodeData.uniformGPU = uniformGPU;\r\n\r\n\t\t\tif ( shaderStage === 'vertex' ) {\r\n\r\n\t\t\t\tthis.bindingsOffset[ 'fragment' ] = bindings.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniformNode;\r\n\r\n\t}\r\n\r\n\tisReference( type ) {\r\n\r\n\t\treturn super.isReference( type ) || type === 'texture_2d' || type === 'texture_cube';\r\n\r\n\t}\r\n\r\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\r\n\r\n\t\tconst map = this.builtins[ shaderStage ];\r\n\r\n\t\tif ( map.has( name ) === false ) {\r\n\r\n\t\t\tmap.set( name, {\r\n\t\t\t\tname,\r\n\t\t\t\tproperty,\r\n\t\t\t\ttype\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn property;\r\n\r\n\t}\r\n\r\n\tgetInstanceIndex() {\r\n\r\n\t\tif ( this.shaderStage === 'vertex' ) {\r\n\r\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\r\n\r\n\t\t}\r\n\r\n\t\treturn 'instanceIndex';\r\n\r\n\t}\r\n\r\n\tgetFrontFacing() {\r\n\r\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\r\n\r\n\t}\r\n\r\n\tgetFragCoord() {\r\n\r\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>', 'fragment' );\r\n\r\n\t}\r\n\r\n\tisFlipY() {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tgetAttributes( shaderStage ) {\r\n\r\n\t\tconst snippets = [];\r\n\r\n\t\tif ( shaderStage === 'compute' ) {\r\n\r\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\r\n\r\n\t\t\tfor ( const { name, property, type } of this.builtins.attribute.values() ) {\r\n\r\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst attributes = this.getAttributesArray();\r\n\r\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\r\n\r\n\t\t\t\tconst attribute = attributes[ index ];\r\n\t\t\t\tconst name = attribute.name;\r\n\t\t\t\tconst type = this.getType( attribute.type );\r\n\r\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn snippets.join( ',\\n\\t' );\r\n\r\n\t}\r\n\r\n\tgetVar( type, name ) {\r\n\r\n\t\treturn `var ${ name } : ${ this.getType( type ) }`;\r\n\r\n\t}\r\n\r\n\tgetVars( shaderStage ) {\r\n\r\n\t\tconst snippets = [];\r\n\t\tconst vars = this.vars[ shaderStage ];\r\n\r\n\t\tfor ( const variable of vars ) {\r\n\r\n\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name ) };` );\r\n\r\n\t\t}\r\n\r\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\r\n\r\n\t}\r\n\r\n\tgetVaryings( shaderStage ) {\r\n\r\n\t\tconst snippets = [];\r\n\r\n\t\tif ( shaderStage === 'vertex' ) {\r\n\r\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\r\n\r\n\t\t\tconst varyings = this.varyings;\r\n\t\t\tconst vars = this.vars[ shaderStage ];\r\n\r\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\r\n\r\n\t\t\t\tconst varying = varyings[ index ];\r\n\r\n\t\t\t\tif ( varying.needsInterpolation ) {\r\n\r\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\r\n\r\n\t\t\t\t\tif ( varying.type === 'int' || varying.type === 'uint' ) {\r\n\r\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\r\n\r\n\t\t\t\t} else if ( vars.includes( varying ) === false ) {\r\n\r\n\t\t\t\t\tvars.push( varying );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const { name, property, type } of this.builtins[ shaderStage ].values() ) {\r\n\r\n\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\r\n\r\n\t\t}\r\n\r\n\t\tconst code = snippets.join( ',\\n\\t' );\r\n\r\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'NodeVaryingsStruct', '\\t' + code ) : code;\r\n\r\n\t}\r\n\r\n\tgetUniforms( shaderStage ) {\r\n\r\n\t\tconst uniforms = this.uniforms[ shaderStage ];\r\n\r\n\t\tconst bindingSnippets = [];\r\n\t\tconst bufferSnippets = [];\r\n\t\tconst groupSnippets = [];\r\n\r\n\t\tlet index = this.bindingsOffset[ shaderStage ];\r\n\r\n\t\tfor ( const uniform of uniforms ) {\r\n\r\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' ) {\r\n\r\n\t\t\t\tif ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\t\t\tbindingSnippets.push( `@group( 0 ) @binding( ${index ++} ) var ${uniform.name}_sampler : sampler;` );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst texture = uniform.node.value;\r\n\r\n\t\t\t\tlet textureType;\r\n\r\n\t\t\t\tif ( texture.isCubeTexture === true ) {\r\n\r\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\r\n\r\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\r\n\r\n\t\t\t\t\ttextureType = 'texture_depth_2d';\r\n\r\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\r\n\r\n\t\t\t\t\ttextureType = 'texture_external';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureType = 'texture_2d<f32>';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbindingSnippets.push( `@group( 0 ) @binding( ${index ++} ) var ${uniform.name} : ${textureType};` );\r\n\r\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' ) {\r\n\r\n\t\t\t\tconst bufferNode = uniform.node;\r\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\r\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\r\n\r\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';\r\n\t\t\t\tconst bufferSnippet = `\\t${uniform.name} : array< ${bufferType}${bufferCountSnippet} >\\n`;\r\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? 'storage,read_write' : 'uniform';\r\n\r\n\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, index ++ ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\r\n\r\n\t\t\t\tif ( Array.isArray( uniform.value ) === true ) {\r\n\r\n\t\t\t\t\tconst length = uniform.value.length;\r\n\r\n\t\t\t\t\tgroupSnippets.push( `uniform ${vectorType}[ ${length} ] ${uniform.name}` );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgroupSnippets.push( `\\t${uniform.name} : ${ vectorType}` );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet code = bindingSnippets.join( '\\n' );\r\n\t\tcode += bufferSnippets.join( '\\n' );\r\n\r\n\t\tif ( groupSnippets.length > 0 ) {\r\n\r\n\t\t\tcode += this._getWGSLStructBinding( 'NodeUniforms', groupSnippets.join( ',\\n' ), 'uniform', index ++ );\r\n\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\r\n\t}\r\n\r\n\tbuildCode() {\r\n\r\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\r\n\r\n\t\tfor ( const shaderStage in shadersData ) {\r\n\r\n\t\t\tlet flow = '// code\\n\\n';\r\n\t\t\tflow += this.flowCode[ shaderStage ];\r\n\r\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\r\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\r\n\r\n\t\t\tfor ( const node of flowNodes ) {\r\n\r\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\r\n\t\t\t\tconst slotName = node.name;\r\n\r\n\t\t\t\tif ( slotName ) {\r\n\r\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\r\n\r\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\r\n\r\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\r\n\r\n\t\t\t\t\tflow += '// result\\n\\t';\r\n\r\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\r\n\r\n\t\t\t\t\t\tflow += 'NodeVaryings.Vertex = ';\r\n\r\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\r\n\r\n\t\t\t\t\t\tflow += 'return ';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tflow += `${ flowSlotData.result };`;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst stageData = shadersData[ shaderStage ];\r\n\r\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\r\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\r\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\r\n\t\t\tstageData.vars = this.getVars( shaderStage );\r\n\t\t\tstageData.codes = this.getCodes( shaderStage );\r\n\t\t\tstageData.flow = flow;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== null ) {\r\n\r\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\r\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetRenderTarget( width, height, options ) {\r\n\r\n\t\treturn new RenderTarget( width, height, options );\r\n\r\n\t}\r\n\r\n\tgetCubeRenderTarget( size, options ) {\r\n\r\n\t\treturn new CubeRenderTarget( size, options );\r\n\r\n\t}\r\n\r\n\tgetMethod( method ) {\r\n\r\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\r\n\r\n\t\t\tthis._include( method );\r\n\r\n\t\t}\r\n\r\n\t\treturn wgslMethods[ method ] || method;\r\n\r\n\t}\r\n\r\n\tgetType( type ) {\r\n\r\n\t\treturn wgslTypeLib[ type ] || type;\r\n\r\n\t}\r\n\r\n\tisAvailable( name ) {\r\n\r\n\t\treturn supports[ name ] === true;\r\n\r\n\t}\r\n\r\n\t_include( name ) {\r\n\r\n\t\twgslPolyfill[ name ].build( this );\r\n\r\n\t}\r\n\r\n\t_getNodeUniform( uniformNode, type ) {\r\n\r\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\r\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\r\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\r\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\r\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\r\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\r\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\r\n\r\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\r\n\r\n\t}\r\n\r\n\t_getWGSLVertexCode( shaderData ) {\r\n\r\n\t\treturn `${ this.getSignature() }\r\n\r\n// uniforms\r\n${shaderData.uniforms}\r\n\r\n// varyings\r\n${shaderData.varyings}\r\n\r\n// codes\r\n${shaderData.codes}\r\n\r\n@vertex\r\nfn main( ${shaderData.attributes} ) -> NodeVaryingsStruct {\r\n\r\n\t// system\r\n\tvar NodeVaryings: NodeVaryingsStruct;\r\n\r\n\t// vars\r\n\t${shaderData.vars}\r\n\r\n\t// flow\r\n\t${shaderData.flow}\r\n\r\n\treturn NodeVaryings;\r\n\r\n}\r\n`;\r\n\r\n\t}\r\n\r\n\t_getWGSLFragmentCode( shaderData ) {\r\n\r\n\t\treturn `${ this.getSignature() }\r\n\r\n// uniforms\r\n${shaderData.uniforms}\r\n\r\n// codes\r\n${shaderData.codes}\r\n\r\n@fragment\r\nfn main( ${shaderData.varyings} ) -> @location( 0 ) vec4<f32> {\r\n\r\n\t// vars\r\n\t${shaderData.vars}\r\n\r\n\t// flow\r\n\t${shaderData.flow}\r\n\r\n}\r\n`;\r\n\r\n\t}\r\n\r\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\r\n\r\n\t\treturn `${ this.getSignature() }\r\n// system\r\nvar<private> instanceIndex : u32;\r\n\r\n// uniforms\r\n${shaderData.uniforms}\r\n\r\n// codes\r\n${shaderData.codes}\r\n\r\n@compute @workgroup_size( ${workgroupSize} )\r\nfn main( ${shaderData.attributes} ) {\r\n\r\n\t// system\r\n\tinstanceIndex = id.x;\r\n\r\n\t// vars\r\n\t${shaderData.vars}\r\n\r\n\t// flow\r\n\t${shaderData.flow}\r\n\r\n}\r\n`;\r\n\r\n\t}\r\n\r\n\t_getWGSLStruct( name, vars ) {\r\n\r\n\t\treturn `\r\nstruct ${name} {\r\n${vars}\r\n};`;\r\n\r\n\t}\r\n\r\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\r\n\r\n\t\tconst structName = name + 'Struct';\r\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\r\n\r\n\t\treturn `${structSnippet}\r\n@binding( ${binding} ) @group( ${group} )\r\nvar<${access}> ${name} : ${structName};`;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WebGPUNodeBuilder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}