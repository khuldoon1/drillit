{"ast":null,"code":"import { fn } from '../../code/FunctionNode.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nexport const mx_hsvtorgb = fn(`vec3 mx_hsvtorgb(vec3 hsv)\n{\n    // Reference for this technique: Foley & van Dam\n    float h = hsv.x; float s = hsv.y; float v = hsv.z;\n    if (s < 0.0001f) {\n      return vec3 (v, v, v);\n    } else {\n        h = 6.0f * (h - floor(h));  // expand to [0..6)\n        int hi = int(trunc(h));\n        float f = h - float(hi);\n        float p = v * (1.0f-s);\n        float q = v * (1.0f-s*f);\n        float t = v * (1.0f-s*(1.0f-f));\n        if (hi == 0)\n            return vec3 (v, t, p);\n        else if (hi == 1)\n            return vec3 (q, v, p);\n        else if (hi == 2)\n            return vec3 (p, v, t);\n        else if (hi == 3)\n            return vec3 (p, q, v);\n        else if (hi == 4)\n            return vec3 (t, p, v);\n        return vec3 (v, p, q);\n    }\n}`);\nexport const mx_rgbtohsv = fn(`vec3 mx_rgbtohsv(vec3 c)\n{\n    // See Foley & van Dam\n    float r = c.x; float g = c.y; float b = c.z;\n    float mincomp = min (r, min(g, b));\n    float maxcomp = max (r, max(g, b));\n    float delta = maxcomp - mincomp;  // chroma\n    float h, s, v;\n    v = maxcomp;\n    if (maxcomp > 0.0f)\n        s = delta / maxcomp;\n    else s = 0.0f;\n    if (s <= 0.0f)\n        h = 0.0f;\n    else {\n        if      (r >= maxcomp) h = (g-b) / delta;\n        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;\n        else                   h = 4.0f + (r-g) / delta;\n        h *= (1.0f/6.0f);\n        if (h < 0.0f)\n            h += 1.0f;\n    }\n    return vec3(h, s, v);\n}`);","map":{"version":3,"names":["fn","mx_hsvtorgb","mx_rgbtohsv"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js"],"sourcesContent":["import { fn } from '../../code/FunctionNode.js';\r\n\r\n// Original shader code from:\r\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\r\n\r\nexport const mx_hsvtorgb = fn( `vec3 mx_hsvtorgb(vec3 hsv)\r\n{\r\n    // Reference for this technique: Foley & van Dam\r\n    float h = hsv.x; float s = hsv.y; float v = hsv.z;\r\n    if (s < 0.0001f) {\r\n      return vec3 (v, v, v);\r\n    } else {\r\n        h = 6.0f * (h - floor(h));  // expand to [0..6)\r\n        int hi = int(trunc(h));\r\n        float f = h - float(hi);\r\n        float p = v * (1.0f-s);\r\n        float q = v * (1.0f-s*f);\r\n        float t = v * (1.0f-s*(1.0f-f));\r\n        if (hi == 0)\r\n            return vec3 (v, t, p);\r\n        else if (hi == 1)\r\n            return vec3 (q, v, p);\r\n        else if (hi == 2)\r\n            return vec3 (p, v, t);\r\n        else if (hi == 3)\r\n            return vec3 (p, q, v);\r\n        else if (hi == 4)\r\n            return vec3 (t, p, v);\r\n        return vec3 (v, p, q);\r\n    }\r\n}` );\r\n\r\nexport const mx_rgbtohsv = fn( `vec3 mx_rgbtohsv(vec3 c)\r\n{\r\n    // See Foley & van Dam\r\n    float r = c.x; float g = c.y; float b = c.z;\r\n    float mincomp = min (r, min(g, b));\r\n    float maxcomp = max (r, max(g, b));\r\n    float delta = maxcomp - mincomp;  // chroma\r\n    float h, s, v;\r\n    v = maxcomp;\r\n    if (maxcomp > 0.0f)\r\n        s = delta / maxcomp;\r\n    else s = 0.0f;\r\n    if (s <= 0.0f)\r\n        h = 0.0f;\r\n    else {\r\n        if      (r >= maxcomp) h = (g-b) / delta;\r\n        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;\r\n        else                   h = 4.0f + (r-g) / delta;\r\n        h *= (1.0f/6.0f);\r\n        if (h < 0.0f)\r\n            h += 1.0f;\r\n    }\r\n    return vec3(h, s, v);\r\n}` );\r\n"],"mappings":"AAAA,SAASA,EAAE,QAAQ,4BAA4B;;AAE/C;AACA;;AAEA,OAAO,MAAMC,WAAW,GAAGD,EAAE,CAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAG,CAAC;AAEJ,OAAO,MAAME,WAAW,GAAGF,EAAE,CAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAG,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}