{"ast":null,"code":"import { GPUFeatureName, GPUTextureFormat, GPULoadOp, GPUStoreOp, GPUIndexFormat, GPUTextureViewDimension } from './utils/WebGPUConstants.js';\nimport WebGPUNodeBuilder from './nodes/WGSLNodeBuilder.js';\nimport Backend from '../common/Backend.js';\nimport { DepthFormat, WebGPUCoordinateSystem } from 'three';\nimport WebGPUUtils from './utils/WebGPUUtils.js';\nimport WebGPUAttributeUtils from './utils/WebGPUAttributeUtils.js';\nimport WebGPUBindingUtils from './utils/WebGPUBindingUtils.js';\nimport WebGPUPipelineUtils from './utils/WebGPUPipelineUtils.js';\nimport WebGPUTextureUtils from './utils/WebGPUTextureUtils.js';\n\n// statics\n\nlet _staticAdapter = null;\nif (navigator.gpu !== undefined) {\n  _staticAdapter = await navigator.gpu.requestAdapter();\n}\n\n//\n\nclass WebGPUBackend extends Backend {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n\n    // some parameters require default values other than \"undefined\"\n\n    this.parameters.antialias = parameters.antialias === true;\n    if (this.parameters.antialias === true) {\n      this.parameters.sampleCount = parameters.sampleCount === undefined ? 4 : parameters.sampleCount;\n    } else {\n      this.parameters.sampleCount = 1;\n    }\n    this.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;\n    this.adapter = null;\n    this.device = null;\n    this.context = null;\n    this.colorBuffer = null;\n    this.depthBuffer = null;\n    this.utils = new WebGPUUtils(this);\n    this.attributeUtils = new WebGPUAttributeUtils(this);\n    this.bindingUtils = new WebGPUBindingUtils(this);\n    this.pipelineUtils = new WebGPUPipelineUtils(this);\n    this.textureUtils = new WebGPUTextureUtils(this);\n  }\n  async init(renderer) {\n    await super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n    const adapterOptions = {\n      powerPreference: parameters.powerPreference\n    };\n    const adapter = await navigator.gpu.requestAdapter(adapterOptions);\n    if (adapter === null) {\n      throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');\n    }\n\n    // feature support\n\n    const features = Object.values(GPUFeatureName);\n    const supportedFeatures = [];\n    for (const name of features) {\n      if (adapter.features.has(name)) {\n        supportedFeatures.push(name);\n      }\n    }\n    const deviceDescriptor = {\n      requiredFeatures: supportedFeatures,\n      requiredLimits: parameters.requiredLimits\n    };\n    const device = await adapter.requestDevice(deviceDescriptor);\n    const context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');\n    this.adapter = adapter;\n    this.device = device;\n    this.context = context;\n    this.updateSize();\n  }\n  get coordinateSystem() {\n    return WebGPUCoordinateSystem;\n  }\n  async getArrayBuffer(attribute) {\n    return await this.attributeUtils.getArrayBuffer(attribute);\n  }\n  beginRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const device = this.device;\n    const descriptor = {\n      colorAttachments: [{\n        view: null\n      }],\n      depthStencilAttachment: {\n        view: null\n      }\n    };\n    const colorAttachment = descriptor.colorAttachments[0];\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    const antialias = this.parameters.antialias;\n    if (renderContext.texture !== null) {\n      const textureData = this.get(renderContext.texture);\n      const depthTextureData = this.get(renderContext.depthTexture);\n\n      // @TODO: Support RenderTarget with antialiasing.\n\n      colorAttachment.view = textureData.texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        baseArrayLayer: renderContext.activeCubeFace,\n        dimension: GPUTextureViewDimension.TwoD\n      });\n      depthStencilAttachment.view = depthTextureData.texture.createView();\n      if (renderContext.stencil && renderContext.depthTexture.format === DepthFormat) {\n        renderContext.stencil = false;\n      }\n    } else {\n      if (antialias === true) {\n        colorAttachment.view = this.colorBuffer.createView();\n        colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n      } else {\n        colorAttachment.view = this.context.getCurrentTexture().createView();\n        colorAttachment.resolveTarget = undefined;\n      }\n      depthStencilAttachment.view = this.depthBuffer.createView();\n    }\n    if (renderContext.clearColor) {\n      colorAttachment.clearValue = renderContext.clearColorValue;\n      colorAttachment.loadOp = GPULoadOp.Clear;\n      colorAttachment.storeOp = GPUStoreOp.Store;\n    } else {\n      colorAttachment.loadOp = GPULoadOp.Load;\n      colorAttachment.storeOp = GPUStoreOp.Store;\n    }\n\n    //\n\n    if (renderContext.depth) {\n      if (renderContext.clearDepth) {\n        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({\n      label: 'renderContext_' + renderContext.id\n    });\n    const currentPass = encoder.beginRenderPass(descriptor);\n\n    //\n\n    renderContextData.descriptor = descriptor;\n    renderContextData.encoder = encoder;\n    renderContextData.currentPass = currentPass;\n\n    //\n\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      currentPass.setScissorRect(x, y, width, height);\n    }\n  }\n  finishRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    renderContextData.currentPass.end();\n    this.device.queue.submit([renderContextData.encoder.finish()]);\n\n    //\n\n    if (renderContext.texture !== null && renderContext.texture.generateMipmaps === true) {\n      this.textureUtils.generateMipmaps(renderContext.texture);\n    }\n  }\n  updateViewport(renderContext) {\n    const {\n      currentPass\n    } = this.get(renderContext);\n    const {\n      x,\n      y,\n      width,\n      height,\n      minDepth,\n      maxDepth\n    } = renderContext.viewportValue;\n    currentPass.setViewport(x, y, width, height, minDepth, maxDepth);\n  }\n  clear(renderContext, color, depth, stencil) {\n    const device = this.device;\n    const renderContextData = this.get(renderContext);\n    const {\n      descriptor\n    } = renderContextData;\n    depth = depth && renderContext.depth;\n    stencil = stencil && renderContext.stencil;\n    const colorAttachment = descriptor.colorAttachments[0];\n    const antialias = this.parameters.antialias;\n\n    // @TODO: Include render target in clear operation.\n    if (antialias === true) {\n      colorAttachment.view = this.colorBuffer.createView();\n      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n    } else {\n      colorAttachment.view = this.context.getCurrentTexture().createView();\n      colorAttachment.resolveTarget = undefined;\n    }\n    descriptor.depthStencilAttachment.view = this.depthBuffer.createView();\n    if (color) {\n      colorAttachment.loadOp = GPULoadOp.Clear;\n      colorAttachment.clearValue = renderContext.clearColorValue;\n    }\n    if (depth) {\n      descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n      descriptor.depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n    }\n    if (stencil) {\n      descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n      descriptor.depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n    }\n    renderContextData.encoder = device.createCommandEncoder({});\n    renderContextData.currentPass = renderContextData.encoder.beginRenderPass(descriptor);\n    renderContextData.currentPass.end();\n    device.queue.submit([renderContextData.encoder.finish()]);\n  }\n\n  // compute\n\n  beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({});\n    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      passEncoderGPU\n    } = this.get(computeGroup);\n\n    // pipeline\n\n    const pipelineGPU = this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind group\n\n    const bindGroupGPU = this.get(bindings).group;\n    passEncoderGPU.setBindGroup(0, bindGroupGPU);\n    passEncoderGPU.dispatchWorkgroups(computeNode.dispatchCount);\n  }\n  finishCompute(computeGroup) {\n    const groupData = this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n\n  // render object\n\n  draw(renderObject, info) {\n    const {\n      object,\n      geometry,\n      context,\n      pipeline\n    } = renderObject;\n    const bindingsData = this.get(renderObject.getBindings());\n    const contextData = this.get(context);\n    const pipelineGPU = this.get(pipeline).pipeline;\n\n    // pipeline\n\n    const passEncoderGPU = contextData.currentPass;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind group\n\n    const bindGroupGPU = bindingsData.group;\n    passEncoderGPU.setBindGroup(0, bindGroupGPU);\n\n    // index\n\n    const index = renderObject.getIndex();\n    const hasIndex = index !== null;\n    if (hasIndex === true) {\n      const buffer = this.get(index).buffer;\n      const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n      passEncoderGPU.setIndexBuffer(buffer, indexFormat);\n    }\n\n    // vertex buffers\n\n    const attributes = renderObject.getAttributes();\n    for (let i = 0, l = attributes.length; i < l; i++) {\n      const buffer = this.get(attributes[i]).buffer;\n      passEncoderGPU.setVertexBuffer(i, buffer);\n    }\n\n    // draw\n\n    const drawRange = geometry.drawRange;\n    const firstVertex = drawRange.start;\n    const instanceCount = this.getInstanceCount(renderObject);\n    if (hasIndex === true) {\n      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;\n      passEncoderGPU.drawIndexed(indexCount, instanceCount, firstVertex, 0, 0);\n      info.update(object, indexCount, instanceCount);\n    } else {\n      const positionAttribute = geometry.attributes.position;\n      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;\n      passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      info.update(object, vertexCount, instanceCount);\n    }\n  }\n\n  // cache key\n\n  needsUpdate(renderObject) {\n    const renderObjectGPU = this.get(renderObject);\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const sampleCount = utils.getSampleCount(renderObject.context);\n    const colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let needsUpdate = false;\n    if (renderObjectGPU.sampleCount !== sampleCount || renderObjectGPU.colorSpace !== colorSpace || renderObjectGPU.colorFormat !== colorFormat || renderObjectGPU.depthStencilFormat !== depthStencilFormat || renderObjectGPU.primitiveTopology !== primitiveTopology) {\n      renderObjectGPU.sampleCount = sampleCount;\n      renderObjectGPU.colorSpace = colorSpace;\n      renderObjectGPU.colorFormat = colorFormat;\n      renderObjectGPU.depthStencilFormat = depthStencilFormat;\n      renderObjectGPU.primitiveTopology = primitiveTopology;\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n  getCacheKey(renderObject) {\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const renderContext = renderObject.context;\n    return [utils.getSampleCount(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material)].join();\n  }\n\n  // textures\n\n  createSampler(texture) {\n    this.textureUtils.createSampler(texture);\n  }\n  destroySampler(texture) {\n    this.textureUtils.destroySampler(texture);\n  }\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture) {\n    this.textureUtils.createTexture(texture);\n  }\n  updateTexture(texture) {\n    this.textureUtils.updateTexture(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n\n  // node builder\n\n  createNodeBuilder(object, renderer) {\n    return new WebGPUNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  createProgram(program) {\n    const programGPU = this.get(program);\n    programGPU.module = {\n      module: this.device.createShaderModule({\n        code: program.code,\n        label: program.stage\n      }),\n      entryPoint: 'main'\n    };\n  }\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  // pipelines\n\n  createRenderPipeline(renderObject) {\n    this.pipelineUtils.createRenderPipeline(renderObject);\n  }\n  createComputePipeline(computePipeline) {\n    this.pipelineUtils.createComputePipeline(computePipeline);\n  }\n\n  // bindings\n\n  createBindings(bindings, pipeline) {\n    this.bindingUtils.createBindings(bindings, pipeline);\n  }\n  updateBindings(bindings, pipeline) {\n    this.bindingUtils.createBindings(bindings, pipeline);\n  }\n  updateBinding(binding) {\n    this.bindingUtils.updateBinding(binding);\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  // canvas\n\n  updateSize() {\n    this._configureContext();\n    this._setupColorBuffer();\n    this._setupDepthBuffer();\n  }\n\n  // utils public\n\n  hasFeature(name) {\n    const adapter = this.adapter || _staticAdapter;\n\n    //\n\n    const features = Object.values(GPUFeatureName);\n    if (features.includes(name) === false) {\n      throw new Error('THREE.WebGPURenderer: Unknown WebGPU GPU feature: ' + name);\n    }\n\n    //\n\n    return adapter.features.has(name);\n  }\n  copyFramebufferToTexture(framebufferTexture, renderContext) {\n    const renderContextData = this.get(renderContext);\n    const {\n      encoder,\n      descriptor\n    } = renderContextData;\n    const sourceGPU = this.context.getCurrentTexture();\n    const destinationGPU = this.get(framebufferTexture).texture;\n    renderContextData.currentPass.end();\n    encoder.copyTextureToTexture({\n      texture: sourceGPU\n    }, {\n      texture: destinationGPU\n    }, [framebufferTexture.image.width, framebufferTexture.image.height]);\n    descriptor.colorAttachments[0].loadOp = GPULoadOp.Load;\n    if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n    if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n    renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n  }\n\n  // utils\n\n  _configureContext() {\n    this.context.configure({\n      device: this.device,\n      format: GPUTextureFormat.BGRA8Unorm,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      alphaMode: 'premultiplied'\n    });\n  }\n  _setupColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize();\n    //const format = navigator.gpu.getPreferredCanvasFormat(); // @TODO: Move to WebGPUUtils\n\n    this.colorBuffer = this.device.createTexture({\n      label: 'colorBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: this.parameters.sampleCount,\n      format: GPUTextureFormat.BGRA8Unorm,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n  }\n  _setupDepthBuffer() {\n    if (this.depthBuffer) this.depthBuffer.destroy();\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize();\n    this.depthBuffer = this.device.createTexture({\n      label: 'depthBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: this.parameters.sampleCount,\n      format: GPUTextureFormat.Depth24PlusStencil8,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n  }\n}\nexport default WebGPUBackend;","map":{"version":3,"names":["GPUFeatureName","GPUTextureFormat","GPULoadOp","GPUStoreOp","GPUIndexFormat","GPUTextureViewDimension","WebGPUNodeBuilder","Backend","DepthFormat","WebGPUCoordinateSystem","WebGPUUtils","WebGPUAttributeUtils","WebGPUBindingUtils","WebGPUPipelineUtils","WebGPUTextureUtils","_staticAdapter","navigator","gpu","undefined","requestAdapter","WebGPUBackend","constructor","parameters","arguments","length","antialias","sampleCount","requiredLimits","adapter","device","context","colorBuffer","depthBuffer","utils","attributeUtils","bindingUtils","pipelineUtils","textureUtils","init","renderer","adapterOptions","powerPreference","Error","features","Object","values","supportedFeatures","name","has","push","deviceDescriptor","requiredFeatures","requestDevice","domElement","getContext","updateSize","coordinateSystem","getArrayBuffer","attribute","beginRender","renderContext","renderContextData","get","descriptor","colorAttachments","view","depthStencilAttachment","colorAttachment","texture","textureData","depthTextureData","depthTexture","createView","baseMipLevel","mipLevelCount","baseArrayLayer","activeCubeFace","dimension","TwoD","stencil","format","resolveTarget","getCurrentTexture","clearColor","clearValue","clearColorValue","loadOp","Clear","storeOp","Store","Load","depth","clearDepth","depthClearValue","clearDepthValue","depthLoadOp","depthStoreOp","clearStencil","stencilClearValue","clearStencilValue","stencilLoadOp","stencilStoreOp","encoder","createCommandEncoder","label","id","currentPass","beginRenderPass","viewport","updateViewport","scissor","x","y","width","height","scissorValue","setScissorRect","finishRender","end","queue","submit","finish","generateMipmaps","minDepth","maxDepth","viewportValue","setViewport","clear","color","beginCompute","computeGroup","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","compute","computeNode","bindings","pipeline","pipelineGPU","setPipeline","bindGroupGPU","group","setBindGroup","dispatchWorkgroups","dispatchCount","finishCompute","groupData","draw","renderObject","info","object","geometry","bindingsData","getBindings","contextData","index","getIndex","hasIndex","buffer","indexFormat","array","Uint16Array","Uint16","Uint32","setIndexBuffer","attributes","getAttributes","i","l","setVertexBuffer","drawRange","firstVertex","start","instanceCount","getInstanceCount","indexCount","count","Infinity","drawIndexed","update","positionAttribute","position","vertexCount","needsUpdate","renderObjectGPU","material","getSampleCount","colorSpace","getCurrentColorSpace","colorFormat","getCurrentColorFormat","depthStencilFormat","getCurrentDepthStencilFormat","primitiveTopology","getPrimitiveTopology","getCacheKey","join","createSampler","destroySampler","createDefaultTexture","createTexture","updateTexture","destroyTexture","createNodeBuilder","createProgram","program","programGPU","module","createShaderModule","code","stage","entryPoint","destroyProgram","delete","createRenderPipeline","createComputePipeline","computePipeline","createBindings","updateBindings","updateBinding","binding","createIndexAttribute","createAttribute","GPUBufferUsage","INDEX","COPY_SRC","COPY_DST","VERTEX","createStorageAttribute","STORAGE","updateAttribute","destroyAttribute","_configureContext","_setupColorBuffer","_setupDepthBuffer","hasFeature","includes","copyFramebufferToTexture","framebufferTexture","sourceGPU","destinationGPU","copyTextureToTexture","image","configure","BGRA8Unorm","usage","GPUTextureUsage","RENDER_ATTACHMENT","alphaMode","destroy","getDrawingBufferSize","size","depthOrArrayLayers","Depth24PlusStencil8"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/WebGPUBackend.js"],"sourcesContent":["import { GPUFeatureName, GPUTextureFormat, GPULoadOp, GPUStoreOp, GPUIndexFormat, GPUTextureViewDimension } from './utils/WebGPUConstants.js';\r\n\r\nimport WebGPUNodeBuilder from './nodes/WGSLNodeBuilder.js';\r\nimport Backend from '../common/Backend.js';\r\n\r\nimport { DepthFormat, WebGPUCoordinateSystem } from 'three';\r\n\r\nimport WebGPUUtils from './utils/WebGPUUtils.js';\r\nimport WebGPUAttributeUtils from './utils/WebGPUAttributeUtils.js';\r\nimport WebGPUBindingUtils from './utils/WebGPUBindingUtils.js';\r\nimport WebGPUPipelineUtils from './utils/WebGPUPipelineUtils.js';\r\nimport WebGPUTextureUtils from './utils/WebGPUTextureUtils.js';\r\n\r\n// statics\r\n\r\nlet _staticAdapter = null;\r\n\r\nif ( navigator.gpu !== undefined ) {\r\n\r\n\t_staticAdapter = await navigator.gpu.requestAdapter();\r\n\r\n}\r\n\r\n//\r\n\r\nclass WebGPUBackend extends Backend {\r\n\r\n\tconstructor( parameters = {} ) {\r\n\r\n\t\tsuper( parameters );\r\n\r\n\t\t// some parameters require default values other than \"undefined\"\r\n\r\n\t\tthis.parameters.antialias = ( parameters.antialias === true );\r\n\r\n\t\tif ( this.parameters.antialias === true ) {\r\n\r\n\t\t\tthis.parameters.sampleCount = ( parameters.sampleCount === undefined ) ? 4 : parameters.sampleCount;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.parameters.sampleCount = 1;\r\n\r\n\t\t}\r\n\r\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\r\n\r\n\t\tthis.adapter = null;\r\n\t\tthis.device = null;\r\n\t\tthis.context = null;\r\n\t\tthis.colorBuffer = null;\r\n\t\tthis.depthBuffer = null;\r\n\r\n\t\tthis.utils = new WebGPUUtils( this );\r\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\r\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\r\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\r\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\r\n\r\n\t}\r\n\r\n\tasync init( renderer ) {\r\n\r\n\t\tawait super.init( renderer );\r\n\r\n\t\t//\r\n\r\n\t\tconst parameters = this.parameters;\r\n\r\n\t\tconst adapterOptions = {\r\n\t\t\tpowerPreference: parameters.powerPreference\r\n\t\t};\r\n\r\n\t\tconst adapter = await navigator.gpu.requestAdapter( adapterOptions );\r\n\r\n\t\tif ( adapter === null ) {\r\n\r\n\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\r\n\r\n\t\t}\r\n\r\n\t\t// feature support\r\n\r\n\t\tconst features = Object.values( GPUFeatureName );\r\n\r\n\t\tconst supportedFeatures = [];\r\n\r\n\t\tfor ( const name of features ) {\r\n\r\n\t\t\tif ( adapter.features.has( name ) ) {\r\n\r\n\t\t\t\tsupportedFeatures.push( name );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst deviceDescriptor = {\r\n\t\t\trequiredFeatures: supportedFeatures,\r\n\t\t\trequiredLimits: parameters.requiredLimits\r\n\t\t};\r\n\r\n\t\tconst device = await adapter.requestDevice( deviceDescriptor );\r\n\r\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\r\n\r\n\t\tthis.adapter = adapter;\r\n\t\tthis.device = device;\r\n\t\tthis.context = context;\r\n\r\n\t\tthis.updateSize();\r\n\r\n\t}\r\n\r\n\tget coordinateSystem() {\r\n\r\n\t\treturn WebGPUCoordinateSystem;\r\n\r\n\t}\r\n\r\n\tasync getArrayBuffer( attribute ) {\r\n\r\n\t\treturn await this.attributeUtils.getArrayBuffer( attribute );\r\n\r\n\t}\r\n\r\n\tbeginRender( renderContext ) {\r\n\r\n\t\tconst renderContextData = this.get( renderContext );\r\n\r\n\t\tconst device = this.device;\r\n\r\n\t\tconst descriptor = {\r\n\t\t\tcolorAttachments: [ {\r\n\t\t\t\tview: null\r\n\t\t\t} ],\r\n\t\t\tdepthStencilAttachment: {\r\n\t\t\t\tview: null\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\r\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\r\n\r\n\t\tconst antialias = this.parameters.antialias;\r\n\r\n\t\tif ( renderContext.texture !== null ) {\r\n\r\n\t\t\tconst textureData = this.get( renderContext.texture );\r\n\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\r\n\r\n\t\t\t// @TODO: Support RenderTarget with antialiasing.\r\n\r\n\t\t\tcolorAttachment.view = textureData.texture.createView( {\r\n\t\t\t\tbaseMipLevel: 0,\r\n\t\t\t\tmipLevelCount: 1,\r\n\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\r\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD\r\n\t\t\t} );\r\n\r\n\t\t\tdepthStencilAttachment.view = depthTextureData.texture.createView();\r\n\r\n\t\t\tif ( renderContext.stencil && renderContext.depthTexture.format === DepthFormat ) {\r\n\r\n\t\t\t\trenderContext.stencil = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( antialias === true ) {\r\n\r\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\r\n\t\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\r\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStencilAttachment.view = this.depthBuffer.createView();\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderContext.clearColor ) {\r\n\r\n\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\r\n\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\r\n\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\r\n\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( renderContext.depth ) {\r\n\r\n\t\t\tif ( renderContext.clearDepth ) {\r\n\r\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\r\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\r\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\r\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderContext.stencil ) {\r\n\r\n\t\t\tif ( renderContext.clearStencil ) {\r\n\r\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\r\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\r\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\r\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\r\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\r\n\r\n\t\t//\r\n\r\n\t\trenderContextData.descriptor = descriptor;\r\n\t\trenderContextData.encoder = encoder;\r\n\t\trenderContextData.currentPass = currentPass;\r\n\r\n\t\t//\r\n\r\n\t\tif ( renderContext.viewport ) {\r\n\r\n\t\t\tthis.updateViewport( renderContext );\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderContext.scissor ) {\r\n\r\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\r\n\r\n\t\t\tcurrentPass.setScissorRect( x, y, width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfinishRender( renderContext ) {\r\n\r\n\t\tconst renderContextData = this.get( renderContext );\r\n\r\n\t\trenderContextData.currentPass.end();\r\n\r\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\r\n\r\n\t\t//\r\n\r\n\t\tif ( renderContext.texture !== null && renderContext.texture.generateMipmaps === true ) {\r\n\r\n\t\t\tthis.textureUtils.generateMipmaps( renderContext.texture );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateViewport( renderContext ) {\r\n\r\n\t\tconst { currentPass } = this.get( renderContext );\r\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\r\n\r\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\r\n\r\n\t}\r\n\r\n\tclear( renderContext, color, depth, stencil ) {\r\n\r\n\t\tconst device = this.device;\r\n\t\tconst renderContextData = this.get( renderContext );\r\n\r\n\t\tconst { descriptor } = renderContextData;\r\n\r\n\t\tdepth = depth && renderContext.depth;\r\n\t\tstencil = stencil && renderContext.stencil;\r\n\r\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\r\n\r\n\t\tconst antialias = this.parameters.antialias;\r\n\r\n\t\t// @TODO: Include render target in clear operation.\r\n\t\tif ( antialias === true ) {\r\n\r\n\t\t\tcolorAttachment.view = this.colorBuffer.createView();\r\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\r\n\t\t\tcolorAttachment.resolveTarget = undefined;\r\n\r\n\t\t}\r\n\r\n\t\tdescriptor.depthStencilAttachment.view = this.depthBuffer.createView();\r\n\r\n\t\tif ( color ) {\r\n\r\n\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\r\n\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( depth ) {\r\n\r\n\t\t\tdescriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\r\n\t\t\tdescriptor.depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( stencil ) {\r\n\r\n\t\t\tdescriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\r\n\t\t\tdescriptor.depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\r\n\r\n\t\t}\r\n\r\n\t\trenderContextData.encoder = device.createCommandEncoder( {} );\r\n\t\trenderContextData.currentPass = renderContextData.encoder.beginRenderPass( descriptor );\r\n\r\n\t\trenderContextData.currentPass.end();\r\n\r\n\t\tdevice.queue.submit( [ renderContextData.encoder.finish() ] );\r\n\r\n\t}\r\n\r\n\t// compute\r\n\r\n\tbeginCompute( computeGroup ) {\r\n\r\n\t\tconst groupGPU = this.get( computeGroup );\r\n\r\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder( {} );\r\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();\r\n\r\n\t}\r\n\r\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\r\n\r\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\r\n\r\n\t\t// pipeline\r\n\r\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\r\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\r\n\r\n\t\t// bind group\r\n\r\n\t\tconst bindGroupGPU = this.get( bindings ).group;\r\n\t\tpassEncoderGPU.setBindGroup( 0, bindGroupGPU );\r\n\r\n\t\tpassEncoderGPU.dispatchWorkgroups( computeNode.dispatchCount );\r\n\r\n\t}\r\n\r\n\tfinishCompute( computeGroup ) {\r\n\r\n\t\tconst groupData = this.get( computeGroup );\r\n\r\n\t\tgroupData.passEncoderGPU.end();\r\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\r\n\r\n\t}\r\n\r\n\t// render object\r\n\r\n\tdraw( renderObject, info ) {\r\n\r\n\t\tconst { object, geometry, context, pipeline } = renderObject;\r\n\r\n\t\tconst bindingsData = this.get( renderObject.getBindings() );\r\n\t\tconst contextData = this.get( context );\r\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\r\n\r\n\t\t// pipeline\r\n\r\n\t\tconst passEncoderGPU = contextData.currentPass;\r\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\r\n\r\n\t\t// bind group\r\n\r\n\t\tconst bindGroupGPU = bindingsData.group;\r\n\t\tpassEncoderGPU.setBindGroup( 0, bindGroupGPU );\r\n\r\n\t\t// index\r\n\r\n\t\tconst index = renderObject.getIndex();\r\n\r\n\t\tconst hasIndex = ( index !== null );\r\n\r\n\t\tif ( hasIndex === true ) {\r\n\r\n\t\t\tconst buffer = this.get( index ).buffer;\r\n\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\r\n\r\n\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\r\n\r\n\t\t}\r\n\r\n\t\t// vertex buffers\r\n\r\n\t\tconst attributes = renderObject.getAttributes();\r\n\r\n\t\tfor ( let i = 0, l = attributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst buffer = this.get( attributes[ i ] ).buffer;\r\n\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\r\n\r\n\t\t}\r\n\r\n\t\t// draw\r\n\r\n\t\tconst drawRange = geometry.drawRange;\r\n\t\tconst firstVertex = drawRange.start;\r\n\r\n\t\tconst instanceCount = this.getInstanceCount( renderObject );\r\n\r\n\t\tif ( hasIndex === true ) {\r\n\r\n\t\t\tconst indexCount = ( drawRange.count !== Infinity ) ? drawRange.count : index.count;\r\n\r\n\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstVertex, 0, 0 );\r\n\r\n\t\t\tinfo.update( object, indexCount, instanceCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst positionAttribute = geometry.attributes.position;\r\n\t\t\tconst vertexCount = ( drawRange.count !== Infinity ) ? drawRange.count : positionAttribute.count;\r\n\r\n\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\r\n\r\n\t\t\tinfo.update( object, vertexCount, instanceCount );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// cache key\r\n\r\n\tneedsUpdate( renderObject ) {\r\n\r\n\t\tconst renderObjectGPU = this.get( renderObject );\r\n\r\n\t\tconst { object, material } = renderObject;\r\n\r\n\t\tconst utils = this.utils;\r\n\r\n\t\tconst sampleCount = utils.getSampleCount( renderObject.context );\r\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\r\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\r\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\r\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\r\n\r\n\t\tlet needsUpdate = false;\r\n\r\n\t\tif ( renderObjectGPU.sampleCount !== sampleCount || renderObjectGPU.colorSpace !== colorSpace ||\r\n\t\t\trenderObjectGPU.colorFormat !== colorFormat || renderObjectGPU.depthStencilFormat !== depthStencilFormat ||\r\n            renderObjectGPU.primitiveTopology !== primitiveTopology ) {\r\n\r\n\t\t\trenderObjectGPU.sampleCount = sampleCount;\r\n\t\t\trenderObjectGPU.colorSpace = colorSpace;\r\n\t\t\trenderObjectGPU.colorFormat = colorFormat;\r\n\t\t\trenderObjectGPU.depthStencilFormat = depthStencilFormat;\r\n\t\t\trenderObjectGPU.primitiveTopology = primitiveTopology;\r\n\r\n\t\t\tneedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn needsUpdate;\r\n\r\n\t}\r\n\r\n\tgetCacheKey( renderObject ) {\r\n\r\n\t\tconst { object, material } = renderObject;\r\n\r\n\t\tconst utils = this.utils;\r\n\t\tconst renderContext = renderObject.context;\r\n\r\n\t\treturn [\r\n\t\t\tutils.getSampleCount( renderContext ),\r\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\r\n\t\t\tutils.getPrimitiveTopology( object, material )\r\n\t\t].join();\r\n\r\n\t}\r\n\r\n\t// textures\r\n\r\n\tcreateSampler( texture ) {\r\n\r\n\t\tthis.textureUtils.createSampler( texture );\r\n\r\n\t}\r\n\r\n\tdestroySampler( texture ) {\r\n\r\n\t\tthis.textureUtils.destroySampler( texture );\r\n\r\n\t}\r\n\r\n\tcreateDefaultTexture( texture ) {\r\n\r\n\t\tthis.textureUtils.createDefaultTexture( texture );\r\n\r\n\t}\r\n\r\n\tcreateTexture( texture ) {\r\n\r\n\t\tthis.textureUtils.createTexture( texture );\r\n\r\n\t}\r\n\r\n\tupdateTexture( texture ) {\r\n\r\n\t\tthis.textureUtils.updateTexture( texture );\r\n\r\n\t}\r\n\r\n\tdestroyTexture( texture ) {\r\n\r\n\t\tthis.textureUtils.destroyTexture( texture );\r\n\r\n\t}\r\n\r\n\t// node builder\r\n\r\n\tcreateNodeBuilder( object, renderer ) {\r\n\r\n\t\treturn new WebGPUNodeBuilder( object, renderer );\r\n\r\n\t}\r\n\r\n\t// program\r\n\r\n\tcreateProgram( program ) {\r\n\r\n\t\tconst programGPU = this.get( program );\r\n\r\n\t\tprogramGPU.module = {\r\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage } ),\r\n\t\t\tentryPoint: 'main'\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tdestroyProgram( program ) {\r\n\r\n\t\tthis.delete( program );\r\n\r\n\t}\r\n\r\n\t// pipelines\r\n\r\n\tcreateRenderPipeline( renderObject ) {\r\n\r\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject );\r\n\r\n\t}\r\n\r\n\tcreateComputePipeline( computePipeline ) {\r\n\r\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline );\r\n\r\n\t}\r\n\r\n\t// bindings\r\n\r\n\tcreateBindings( bindings, pipeline ) {\r\n\r\n\t\tthis.bindingUtils.createBindings( bindings, pipeline );\r\n\r\n\t}\r\n\r\n\tupdateBindings( bindings, pipeline ) {\r\n\r\n\t\tthis.bindingUtils.createBindings( bindings, pipeline );\r\n\r\n\t}\r\n\r\n\tupdateBinding( binding ) {\r\n\r\n\t\tthis.bindingUtils.updateBinding( binding );\r\n\r\n\t}\r\n\r\n\t// attributes\r\n\r\n\tcreateIndexAttribute( attribute ) {\r\n\r\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\r\n\r\n\t}\r\n\r\n\tcreateAttribute( attribute ) {\r\n\r\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\r\n\r\n\t}\r\n\r\n\tcreateStorageAttribute( attribute ) {\r\n\r\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\r\n\r\n\t}\r\n\r\n\tupdateAttribute( attribute ) {\r\n\r\n\t\tthis.attributeUtils.updateAttribute( attribute );\r\n\r\n\t}\r\n\r\n\tdestroyAttribute( attribute ) {\r\n\r\n\t\tthis.attributeUtils.destroyAttribute( attribute );\r\n\r\n\t}\r\n\r\n\t// canvas\r\n\r\n\tupdateSize() {\r\n\r\n\t\tthis._configureContext();\r\n\t\tthis._setupColorBuffer();\r\n\t\tthis._setupDepthBuffer();\r\n\r\n\t}\r\n\r\n\t// utils public\r\n\r\n\thasFeature( name ) {\r\n\r\n\t\tconst adapter = this.adapter || _staticAdapter;\r\n\r\n\t\t//\r\n\r\n\t\tconst features = Object.values( GPUFeatureName );\r\n\r\n\t\tif ( features.includes( name ) === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Unknown WebGPU GPU feature: ' + name );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\treturn adapter.features.has( name );\r\n\r\n\t}\r\n\r\n\tcopyFramebufferToTexture( framebufferTexture, renderContext ) {\r\n\r\n\t\tconst renderContextData = this.get( renderContext );\r\n\r\n\t\tconst { encoder, descriptor } = renderContextData;\r\n\r\n\t\tconst sourceGPU = this.context.getCurrentTexture();\r\n\t\tconst destinationGPU = this.get( framebufferTexture ).texture;\r\n\r\n\t\trenderContextData.currentPass.end();\r\n\r\n\t\tencoder.copyTextureToTexture(\r\n\t\t\t{\r\n\t\t\t  texture: sourceGPU\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t  texture: destinationGPU\r\n\t\t\t},\r\n\t\t\t[\r\n\t\t\t\tframebufferTexture.image.width,\r\n\t\t\t\tframebufferTexture.image.height\r\n\t\t\t]\r\n\t\t);\r\n\r\n\t\tdescriptor.colorAttachments[ 0 ].loadOp = GPULoadOp.Load;\r\n\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\r\n\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\r\n\r\n\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\r\n\r\n\t}\r\n\r\n\t// utils\r\n\r\n\t_configureContext() {\r\n\r\n\t\tthis.context.configure( {\r\n\t\t\tdevice: this.device,\r\n\t\t\tformat: GPUTextureFormat.BGRA8Unorm,\r\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\r\n\t\t\talphaMode: 'premultiplied'\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_setupColorBuffer() {\r\n\r\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\r\n\r\n\t\tconst { width, height } = this.getDrawingBufferSize();\r\n\t\t//const format = navigator.gpu.getPreferredCanvasFormat(); // @TODO: Move to WebGPUUtils\r\n\r\n\t\tthis.colorBuffer = this.device.createTexture( {\r\n\t\t\tlabel: 'colorBuffer',\r\n\t\t\tsize: {\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height,\r\n\t\t\t\tdepthOrArrayLayers: 1\r\n\t\t\t},\r\n\t\t\tsampleCount: this.parameters.sampleCount,\r\n\t\t\tformat: GPUTextureFormat.BGRA8Unorm,\r\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_setupDepthBuffer() {\r\n\r\n\t\tif ( this.depthBuffer ) this.depthBuffer.destroy();\r\n\r\n\t\tconst { width, height } = this.getDrawingBufferSize();\r\n\r\n\t\tthis.depthBuffer = this.device.createTexture( {\r\n\t\t\tlabel: 'depthBuffer',\r\n\t\t\tsize: {\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height,\r\n\t\t\t\tdepthOrArrayLayers: 1\r\n\t\t\t},\r\n\t\t\tsampleCount: this.parameters.sampleCount,\r\n\t\t\tformat: GPUTextureFormat.Depth24PlusStencil8,\r\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WebGPUBackend;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}