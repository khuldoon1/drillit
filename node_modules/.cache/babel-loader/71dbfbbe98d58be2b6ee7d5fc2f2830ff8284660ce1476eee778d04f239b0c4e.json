{"ast":null,"code":"import DataMap from './DataMap.js';\nimport RenderPipeline from './RenderPipeline.js';\nimport ComputePipeline from './ComputePipeline.js';\nimport ProgrammableStage from './ProgrammableStage.js';\nclass Pipelines extends DataMap {\n  constructor(backend, nodes) {\n    super();\n    this.backend = backend;\n    this.nodes = nodes;\n    this.bindings = null; // set by the bindings\n\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  getForCompute(computeNode) {\n    const {\n      backend\n    } = this;\n    const data = this.get(computeNode);\n    if (data.pipeline === undefined) {\n      // release previous cache\n\n      this._releasePipeline(computeNode);\n\n      // get shader\n\n      const nodeBuilder = this.nodes.getForCompute(computeNode);\n\n      // programmable stage\n\n      let stageCompute = this.programs.compute.get(nodeBuilder.computeShader);\n      if (stageCompute === undefined) {\n        stageCompute = new ProgrammableStage(nodeBuilder.computeShader, 'compute');\n        this.programs.compute.set(nodeBuilder.computeShader, stageCompute);\n        backend.createProgram(stageCompute);\n      }\n\n      // determine compute pipeline\n\n      const pipeline = this._getComputePipeline(stageCompute);\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  getForRender(renderObject) {\n    const {\n      backend\n    } = this;\n    const data = this.get(renderObject);\n    if (this._needsUpdate(renderObject)) {\n      // release previous cache\n\n      this._releasePipeline(renderObject);\n\n      // get shader\n\n      const nodeBuilder = this.nodes.getForRender(renderObject);\n\n      // programmable stages\n\n      let stageVertex = this.programs.vertex.get(nodeBuilder.vertexShader);\n      if (stageVertex === undefined) {\n        stageVertex = new ProgrammableStage(nodeBuilder.vertexShader, 'vertex');\n        this.programs.vertex.set(nodeBuilder.vertexShader, stageVertex);\n        backend.createProgram(stageVertex);\n      }\n      let stageFragment = this.programs.fragment.get(nodeBuilder.fragmentShader);\n      if (stageFragment === undefined) {\n        stageFragment = new ProgrammableStage(nodeBuilder.fragmentShader, 'fragment');\n        this.programs.fragment.set(nodeBuilder.fragmentShader, stageFragment);\n        backend.createProgram(stageFragment);\n      }\n\n      // determine render pipeline\n\n      const pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment);\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      stageFragment.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  delete(object) {\n    this._releasePipeline(object);\n    super.delete(object);\n  }\n  dispose() {\n    super.dispose();\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  _getComputePipeline(stageCompute) {\n    // check for existing pipeline\n\n    const cacheKey = 'compute:' + stageCompute.id;\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      this.caches.set(cacheKey, pipeline);\n      this.backend.createComputePipeline(pipeline);\n    }\n    return pipeline;\n  }\n  _getRenderPipeline(renderObject, stageVertex, stageFragment) {\n    // check for existing pipeline\n\n    const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = pipeline;\n      this.backend.createRenderPipeline(renderObject);\n    } else {\n      // assign a shared pipeline to renderObject\n\n      renderObject.pipeline = pipeline;\n    }\n    return pipeline;\n  }\n  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    const {\n      material\n    } = renderObject;\n    const parameters = [stageVertex.id, stageFragment.id, material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, this.backend.getCacheKey(renderObject)];\n    return parameters.join();\n  }\n  _releasePipeline(object) {\n    const pipeline = this.get(object).pipeline;\n\n    //this.bindings.delete( object );\n\n    if (pipeline && --pipeline.usedTimes === 0) {\n      this.caches.delete(pipeline.cacheKey);\n      if (pipeline.isComputePipeline) {\n        this._releaseProgram(pipeline.computeProgram);\n      } else {\n        this._releaseProgram(pipeline.vertexProgram);\n        this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n  }\n  _releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      const code = program.code;\n      const stage = program.stage;\n      this.programs[stage].delete(code);\n    }\n  }\n  _needsUpdate(renderObject) {\n    const data = this.get(renderObject);\n    const material = renderObject.material;\n    let needsUpdate = this.backend.needsUpdate(renderObject);\n\n    // check material state\n\n    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side) {\n      data.material = material;\n      data.materialVersion = material.version;\n      data.transparent = material.transparent;\n      data.blending = material.blending;\n      data.premultipliedAlpha = material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      data.blendDst = material.blendDst;\n      data.blendEquation = material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n      data.blendDstAlpha = material.blendDstAlpha;\n      data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite = material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      data.depthTest = material.depthTest;\n      data.depthFunc = material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      data.stencilFunc = material.stencilFunc;\n      data.stencilFail = material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n      data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = material.stencilFuncMask;\n      data.stencilWriteMask = material.stencilWriteMask;\n      data.side = material.side;\n      needsUpdate = true;\n    }\n    return needsUpdate || data.pipeline !== undefined;\n  }\n}\nexport default Pipelines;","map":{"version":3,"names":["DataMap","RenderPipeline","ComputePipeline","ProgrammableStage","Pipelines","constructor","backend","nodes","bindings","caches","Map","programs","vertex","fragment","compute","getForCompute","computeNode","data","get","pipeline","undefined","_releasePipeline","nodeBuilder","stageCompute","computeShader","set","createProgram","_getComputePipeline","usedTimes","getForRender","renderObject","_needsUpdate","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderPipeline","delete","object","dispose","cacheKey","id","createComputePipeline","_getRenderCacheKey","createRenderPipeline","material","parameters","transparent","blending","premultipliedAlpha","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","colorWrite","depthWrite","depthTest","depthFunc","stencilWrite","stencilFunc","stencilFail","stencilZFail","stencilZPass","stencilFuncMask","stencilWriteMask","side","getCacheKey","join","isComputePipeline","_releaseProgram","computeProgram","vertexProgram","fragmentProgram","program","code","stage","needsUpdate","materialVersion","version"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/common/Pipelines.js"],"sourcesContent":["import DataMap from './DataMap.js';\r\nimport RenderPipeline from './RenderPipeline.js';\r\nimport ComputePipeline from './ComputePipeline.js';\r\nimport ProgrammableStage from './ProgrammableStage.js';\r\n\r\nclass Pipelines extends DataMap {\r\n\r\n\tconstructor( backend, nodes ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.backend = backend;\r\n\t\tthis.nodes = nodes;\r\n\r\n\t\tthis.bindings = null; // set by the bindings\r\n\r\n\t\tthis.caches = new Map();\r\n\t\tthis.programs = {\r\n\t\t\tvertex: new Map(),\r\n\t\t\tfragment: new Map(),\r\n\t\t\tcompute: new Map()\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tgetForCompute( computeNode ) {\r\n\r\n\t\tconst { backend } = this;\r\n\r\n\t\tconst data = this.get( computeNode );\r\n\r\n\t\tif ( data.pipeline === undefined ) {\r\n\r\n\t\t\t// release previous cache\r\n\r\n\t\t\tthis._releasePipeline( computeNode );\r\n\r\n\t\t\t// get shader\r\n\r\n\t\t\tconst nodeBuilder = this.nodes.getForCompute( computeNode );\r\n\r\n\t\t\t// programmable stage\r\n\r\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilder.computeShader );\r\n\r\n\t\t\tif ( stageCompute === undefined ) {\r\n\r\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilder.computeShader, 'compute' );\r\n\t\t\t\tthis.programs.compute.set( nodeBuilder.computeShader, stageCompute );\r\n\r\n\t\t\t\tbackend.createProgram( stageCompute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// determine compute pipeline\r\n\r\n\t\t\tconst pipeline = this._getComputePipeline( stageCompute );\r\n\r\n\t\t\t// keep track of all used times\r\n\r\n\t\t\tpipeline.usedTimes ++;\r\n\t\t\tstageCompute.usedTimes ++;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tdata.pipeline = pipeline;\r\n\r\n\t\t}\r\n\r\n\t\treturn data.pipeline;\r\n\r\n\t}\r\n\r\n\tgetForRender( renderObject ) {\r\n\r\n\t\tconst { backend } = this;\r\n\r\n\t\tconst data = this.get( renderObject );\r\n\r\n\t\tif ( this._needsUpdate( renderObject ) ) {\r\n\r\n\t\t\t// release previous cache\r\n\r\n\t\t\tthis._releasePipeline( renderObject );\r\n\r\n\t\t\t// get shader\r\n\r\n\t\t\tconst nodeBuilder = this.nodes.getForRender( renderObject );\r\n\r\n\t\t\t// programmable stages\r\n\r\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilder.vertexShader );\r\n\r\n\t\t\tif ( stageVertex === undefined ) {\r\n\r\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilder.vertexShader, 'vertex' );\r\n\t\t\t\tthis.programs.vertex.set( nodeBuilder.vertexShader, stageVertex );\r\n\r\n\t\t\t\tbackend.createProgram( stageVertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilder.fragmentShader );\r\n\r\n\t\t\tif ( stageFragment === undefined ) {\r\n\r\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilder.fragmentShader, 'fragment' );\r\n\t\t\t\tthis.programs.fragment.set( nodeBuilder.fragmentShader, stageFragment );\r\n\r\n\t\t\t\tbackend.createProgram( stageFragment );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// determine render pipeline\r\n\r\n\t\t\tconst pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment );\r\n\r\n\t\t\t// keep track of all used times\r\n\r\n\t\t\tpipeline.usedTimes ++;\r\n\t\t\tstageVertex.usedTimes ++;\r\n\t\t\tstageFragment.usedTimes ++;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tdata.pipeline = pipeline;\r\n\r\n\t\t}\r\n\r\n\t\treturn data.pipeline;\r\n\r\n\t}\r\n\r\n\tdelete( object ) {\r\n\r\n\t\tthis._releasePipeline( object );\r\n\r\n\t\tsuper.delete( object );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tsuper.dispose();\r\n\r\n\t\tthis.caches = new Map();\r\n\t\tthis.programs = {\r\n\t\t\tvertex: new Map(),\r\n\t\t\tfragment: new Map(),\r\n\t\t\tcompute: new Map()\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t_getComputePipeline( stageCompute ) {\r\n\r\n\t\t// check for existing pipeline\r\n\r\n\t\tconst cacheKey = 'compute:' + stageCompute.id;\r\n\r\n\t\tlet pipeline = this.caches.get( cacheKey );\r\n\r\n\t\tif ( pipeline === undefined ) {\r\n\r\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\r\n\r\n\t\t\tthis.caches.set( cacheKey, pipeline );\r\n\r\n\t\t\tthis.backend.createComputePipeline( pipeline );\r\n\r\n\t\t}\r\n\r\n\t\treturn pipeline;\r\n\r\n\t}\r\n\r\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment ) {\r\n\r\n\t\t// check for existing pipeline\r\n\r\n\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\r\n\r\n\t\tlet pipeline = this.caches.get( cacheKey );\r\n\r\n\t\tif ( pipeline === undefined ) {\r\n\r\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\r\n\r\n\t\t\tthis.caches.set( cacheKey, pipeline );\r\n\r\n\t\t\trenderObject.pipeline = pipeline;\r\n\r\n\t\t\tthis.backend.createRenderPipeline( renderObject );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// assign a shared pipeline to renderObject\r\n\r\n\t\t\trenderObject.pipeline = pipeline;\r\n\r\n\t\t}\r\n\r\n\t\treturn pipeline;\r\n\r\n\t}\r\n\r\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\r\n\r\n\t\tconst { material } = renderObject;\r\n\r\n\t\tconst parameters = [\r\n\t\t\tstageVertex.id, stageFragment.id,\r\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\r\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\r\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\r\n\t\t\tmaterial.colorWrite,\r\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\r\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\r\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\r\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\r\n\t\t\tmaterial.side,\r\n\t\t\tthis.backend.getCacheKey( renderObject )\r\n\t\t];\r\n\r\n\t\treturn parameters.join();\r\n\r\n\t}\r\n\r\n\t_releasePipeline( object ) {\r\n\r\n\t\tconst pipeline = this.get( object ).pipeline;\r\n\r\n\t\t//this.bindings.delete( object );\r\n\r\n\t\tif ( pipeline && -- pipeline.usedTimes === 0 ) {\r\n\r\n\t\t\tthis.caches.delete( pipeline.cacheKey );\r\n\r\n\t\t\tif ( pipeline.isComputePipeline ) {\r\n\r\n\t\t\t\tthis._releaseProgram( pipeline.computeProgram );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._releaseProgram( pipeline.vertexProgram );\r\n\t\t\t\tthis._releaseProgram( pipeline.fragmentProgram );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_releaseProgram( program ) {\r\n\r\n\t\tif ( -- program.usedTimes === 0 ) {\r\n\r\n\t\t\tconst code = program.code;\r\n\t\t\tconst stage = program.stage;\r\n\r\n\t\t\tthis.programs[ stage ].delete( code );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_needsUpdate( renderObject ) {\r\n\r\n\t\tconst data = this.get( renderObject );\r\n\t\tconst material = renderObject.material;\r\n\r\n\t\tlet needsUpdate = this.backend.needsUpdate( renderObject );\r\n\r\n\t\t// check material state\r\n\r\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\r\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\r\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\r\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\r\n\t\t\tdata.colorWrite !== material.colorWrite ||\r\n\t\t\tdata.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\r\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\r\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\r\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\r\n\t\t\tdata.side !== material.side\r\n\t\t) {\r\n\r\n\t\t\tdata.material = material; data.materialVersion = material.version;\r\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\r\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\r\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\r\n\t\t\tdata.colorWrite = material.colorWrite;\r\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\r\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\r\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\r\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\r\n\t\t\tdata.side = material.side;\r\n\r\n\t\t\tneedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn needsUpdate || data.pipeline !== undefined;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default Pipelines;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}