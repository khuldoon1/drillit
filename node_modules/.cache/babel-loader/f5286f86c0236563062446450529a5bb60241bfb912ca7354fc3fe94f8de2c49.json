{"ast":null,"code":"import { Float16BufferAttribute } from 'three';\nconst typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);\nconst typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ['float16']]]);\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Uint32Array, 'uint32'], [Float32Array, 'float32']]);\nclass WebGPUAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, usage) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const array = bufferAttribute.array;\n    const size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441\n\n    const buffer = device.createBuffer({\n      label: bufferAttribute.name,\n      size: size,\n      usage: usage,\n      mappedAtCreation: true\n    });\n    new array.constructor(buffer.getMappedRange()).set(array);\n    buffer.unmap();\n    backend.get(attribute).buffer = buffer;\n  }\n  updateAttribute(attribute) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = backend.get(attribute).buffer;\n    const array = bufferAttribute.array;\n    const updateRange = bufferAttribute.updateRange;\n    if (updateRange.count === -1) {\n      // Not using update ranges\n\n      device.queue.writeBuffer(buffer, 0, array, 0);\n    } else {\n      device.queue.writeBuffer(buffer, 0, array, updateRange.offset * array.BYTES_PER_ELEMENT, updateRange.count * array.BYTES_PER_ELEMENT);\n      updateRange.count = -1; // reset range\n    }\n  }\n\n  createShaderAttributes(renderObject) {\n    const attributes = renderObject.getAttributes();\n    const shaderAttributes = [];\n    for (let slot = 0; slot < attributes.length; slot++) {\n      const geometryAttribute = attributes[slot];\n      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n      const format = this._getVertexFormat(geometryAttribute);\n      let arrayStride = geometryAttribute.itemSize * bytesPerElement;\n      let offset = 0;\n      if (geometryAttribute.isInterleavedBufferAttribute === true) {\n        // @TODO: It can be optimized for \"vertexBuffers\" on RenderPipeline\n\n        arrayStride = geometryAttribute.data.stride * bytesPerElement;\n        offset = geometryAttribute.offset * bytesPerElement;\n      }\n      shaderAttributes.push({\n        geometryAttribute,\n        arrayStride,\n        offset,\n        format,\n        slot\n      });\n    }\n    return shaderAttributes;\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const data = backend.get(attribute);\n    data.buffer.destroy();\n    backend.delete(attribute);\n  }\n  async getArrayBuffer(attribute) {\n    const backend = this.backend;\n    const device = backend.device;\n    const data = backend.get(attribute);\n\n    //const bufferAttribute = this._getBufferAttribute( attribute );\n\n    const bufferGPU = data.buffer;\n    const size = bufferGPU.size;\n    let readBufferGPU = data.readBuffer;\n    let needsUnmap = true;\n    if (readBufferGPU === undefined) {\n      readBufferGPU = device.createBuffer({\n        label: attribute.name,\n        size,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n      needsUnmap = false;\n      data.readBuffer = readBufferGPU;\n    }\n    const cmdEncoder = device.createCommandEncoder({});\n    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);\n    if (needsUnmap) readBufferGPU.unmap();\n    const gpuCommands = cmdEncoder.finish();\n    device.queue.submit([gpuCommands]);\n    await readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = readBufferGPU.getMappedRange();\n    return arrayBuffer;\n  }\n  _getVertexFormat(geometryAttribute) {\n    const {\n      itemSize,\n      normalized\n    } = geometryAttribute;\n    const ArrayType = geometryAttribute.array.constructor;\n    const AttributeType = geometryAttribute.constructor;\n    let format;\n    if (itemSize == 1) {\n      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    } else {\n      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        if (paddedItemSize % 1) {\n          throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');\n        }\n        format = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if (!format) {\n      console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');\n    }\n    return format;\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nexport default WebGPUAttributeUtils;","map":{"version":3,"names":["Float16BufferAttribute","typedArraysToVertexFormatPrefix","Map","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","constructor","backend","createAttribute","attribute","usage","bufferAttribute","_getBufferAttribute","device","array","size","byteLength","buffer","createBuffer","label","name","mappedAtCreation","getMappedRange","set","unmap","get","updateAttribute","updateRange","count","queue","writeBuffer","offset","BYTES_PER_ELEMENT","createShaderAttributes","renderObject","attributes","getAttributes","shaderAttributes","slot","length","geometryAttribute","bytesPerElement","format","_getVertexFormat","arrayStride","itemSize","isInterleavedBufferAttribute","data","stride","push","destroyAttribute","destroy","delete","getArrayBuffer","bufferGPU","readBufferGPU","readBuffer","needsUnmap","undefined","GPUBufferUsage","COPY_DST","MAP_READ","cmdEncoder","createCommandEncoder","copyBufferToBuffer","gpuCommands","finish","submit","mapAsync","GPUMapMode","READ","arrayBuffer","normalized","ArrayType","AttributeType","prefixOptions","prefix","bytesPerUnit","paddedBytesPerUnit","Math","floor","paddedItemSize","Error","console","error"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUAttributeUtils.js"],"sourcesContent":["import { Float16BufferAttribute } from 'three';\r\n\r\nconst typedArraysToVertexFormatPrefix = new Map( [\r\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\r\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\r\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\r\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\r\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\r\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\r\n\t[ Float32Array, [ 'float32', ]],\r\n] );\r\n\r\nconst typedAttributeToVertexFormatPrefix = new Map( [\r\n\t[ Float16BufferAttribute, [ 'float16', ]],\r\n] );\r\n\r\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\r\n\t[ Int32Array, 'sint32' ],\r\n\t[ Uint32Array, 'uint32' ],\r\n\t[ Float32Array, 'float32' ]\r\n] );\r\n\r\nclass WebGPUAttributeUtils {\r\n\r\n\tconstructor( backend ) {\r\n\r\n\t\tthis.backend = backend;\r\n\r\n\t}\r\n\r\n\tcreateAttribute( attribute, usage ) {\r\n\r\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst device = backend.device;\r\n\r\n\t\tconst array = bufferAttribute.array;\r\n\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\r\n\r\n\t\tconst buffer = device.createBuffer( {\r\n\t\t\tlabel: bufferAttribute.name,\r\n\t\t\tsize: size,\r\n\t\t\tusage: usage,\r\n\t\t\tmappedAtCreation: true\r\n\t\t} );\r\n\r\n\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\r\n\r\n\t\tbuffer.unmap();\r\n\r\n\t\tbackend.get( attribute ).buffer = buffer;\r\n\r\n\t}\r\n\r\n\tupdateAttribute( attribute ) {\r\n\r\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst device = backend.device;\r\n\r\n\t\tconst buffer = backend.get( attribute ).buffer;\r\n\r\n\t\tconst array = bufferAttribute.array;\r\n\t\tconst updateRange = bufferAttribute.updateRange;\r\n\r\n\t\tif ( updateRange.count === - 1 ) {\r\n\r\n\t\t\t// Not using update ranges\r\n\r\n\t\t\tdevice.queue.writeBuffer(\r\n\t\t\t\tbuffer,\r\n\t\t\t\t0,\r\n\t\t\t\tarray,\r\n\t\t\t\t0\r\n\t\t\t);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdevice.queue.writeBuffer(\r\n\t\t\t\tbuffer,\r\n\t\t\t\t0,\r\n\t\t\t\tarray,\r\n\t\t\t\tupdateRange.offset * array.BYTES_PER_ELEMENT,\r\n\t\t\t\tupdateRange.count * array.BYTES_PER_ELEMENT\r\n\t\t\t);\r\n\r\n\t\t\tupdateRange.count = - 1; // reset range\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcreateShaderAttributes( renderObject ) {\r\n\r\n\t\tconst attributes = renderObject.getAttributes();\r\n\t\tconst shaderAttributes = [];\r\n\r\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\r\n\r\n\t\t\tconst geometryAttribute = attributes[ slot ];\r\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\r\n\r\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\r\n\r\n\t\t\tlet arrayStride = geometryAttribute.itemSize * bytesPerElement;\r\n\t\t\tlet offset = 0;\r\n\r\n\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\r\n\r\n\t\t\t\t// @TODO: It can be optimized for \"vertexBuffers\" on RenderPipeline\r\n\r\n\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\r\n\t\t\t\toffset = geometryAttribute.offset * bytesPerElement;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshaderAttributes.push( {\r\n\t\t\t\tgeometryAttribute,\r\n\t\t\t\tarrayStride,\r\n\t\t\t\toffset,\r\n\t\t\t\tformat,\r\n\t\t\t\tslot\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn shaderAttributes;\r\n\r\n\t}\r\n\r\n\tdestroyAttribute( attribute ) {\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst data = backend.get( attribute );\r\n\r\n\t\tdata.buffer.destroy();\r\n\r\n\t\tbackend.delete( attribute );\r\n\r\n\t}\r\n\r\n\tasync getArrayBuffer( attribute ) {\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst device = backend.device;\r\n\r\n\t\tconst data = backend.get( attribute );\r\n\r\n\t\t//const bufferAttribute = this._getBufferAttribute( attribute );\r\n\r\n\t\tconst bufferGPU = data.buffer;\r\n\t\tconst size = bufferGPU.size;\r\n\r\n\t\tlet readBufferGPU = data.readBuffer;\r\n\t\tlet needsUnmap = true;\r\n\r\n\t\tif ( readBufferGPU === undefined ) {\r\n\r\n\t\t\treadBufferGPU = device.createBuffer( {\r\n\t\t\t\tlabel: attribute.name,\r\n\t\t\t\tsize,\r\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n\t\t\t} );\r\n\r\n\t\t\tneedsUnmap = false;\r\n\r\n\t\t\tdata.readBuffer = readBufferGPU;\r\n\r\n\t\t}\r\n\r\n\t\tconst cmdEncoder = device.createCommandEncoder( {} );\r\n\r\n\t\tcmdEncoder.copyBufferToBuffer(\r\n\t\t\tbufferGPU,\r\n\t\t\t0,\r\n\t\t\treadBufferGPU,\r\n\t\t\t0,\r\n\t\t\tsize\r\n\t\t);\r\n\r\n\t\tif ( needsUnmap ) readBufferGPU.unmap();\r\n\r\n\t\tconst gpuCommands = cmdEncoder.finish();\r\n\t\tdevice.queue.submit( [ gpuCommands ] );\r\n\r\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\r\n\r\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\r\n\r\n\t\treturn arrayBuffer;\r\n\r\n\t}\r\n\r\n\t_getVertexFormat( geometryAttribute ) {\r\n\r\n\t\tconst { itemSize, normalized } = geometryAttribute;\r\n\t\tconst ArrayType = geometryAttribute.array.constructor;\r\n\t\tconst AttributeType = geometryAttribute.constructor;\r\n\r\n\t\tlet format;\r\n\r\n\t\tif ( itemSize == 1 ) {\r\n\r\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\r\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\r\n\r\n\t\t\tif ( prefix ) {\r\n\r\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\r\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\r\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\r\n\r\n\t\t\t\tif ( paddedItemSize % 1 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! format ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\r\n\r\n\t\t}\r\n\r\n\t\treturn format;\r\n\r\n\t}\r\n\r\n\t_getBufferAttribute( attribute ) {\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WebGPUAttributeUtils;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}