{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { cache } from '../core/CacheNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { roughness } from '../core/PropertyNode.js';\nimport { equirectUV } from '../utils/EquirectUVNode.js';\nimport { specularMIPLevel } from '../utils/SpecularMIPLevelNode.js';\nimport { cameraViewMatrix } from '../accessors/CameraNode.js';\nimport { transformedNormalView, transformedNormalWorld } from '../accessors/NormalNode.js';\nimport { positionViewDirection } from '../accessors/PositionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { float, vec2 } from '../shadernode/ShaderNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nclass EnvironmentNode extends LightingNode {\n  constructor() {\n    let envNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.envNode = envNode;\n  }\n  construct(builder) {\n    let envNode = this.envNode;\n    const properties = builder.getNodeProperties(this);\n    if (envNode.isTextureNode && envNode.value.isCubeTexture !== true) {\n      const texture = envNode.value;\n      const renderer = builder.renderer;\n\n      // @TODO: Add dispose logic here\n      const cubeRTT = builder.getCubeRenderTarget(512).fromEquirectangularTexture(renderer, texture);\n      envNode = cubeTexture(cubeRTT.texture);\n    }\n    let reflectVec;\n    let radianceTextureUVNode;\n    let irradianceTextureUVNode;\n    const radianceContext = context(envNode, {\n      getUVNode: textureNode => {\n        let node = null;\n        if (reflectVec === undefined) {\n          reflectVec = positionViewDirection.negate().reflect(transformedNormalView);\n          reflectVec = roughness.mul(roughness).mix(reflectVec, transformedNormalView).normalize();\n          reflectVec = reflectVec.transformDirection(cameraViewMatrix);\n        }\n        if (textureNode.isCubeTextureNode) {\n          node = reflectVec;\n        } else if (textureNode.isTextureNode) {\n          if (radianceTextureUVNode === undefined) {\n            // @TODO: Needed PMREM\n\n            radianceTextureUVNode = equirectUV(reflectVec);\n          }\n          node = radianceTextureUVNode;\n        }\n        return node;\n      },\n      getSamplerLevelNode: () => {\n        return roughness;\n      },\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {\n        return specularMIPLevel(textureNode, levelNode);\n      }\n    });\n    const irradianceContext = context(envNode, {\n      getUVNode: textureNode => {\n        let node = null;\n        if (textureNode.isCubeTextureNode) {\n          node = transformedNormalWorld;\n        } else if (textureNode.isTextureNode) {\n          if (irradianceTextureUVNode === undefined) {\n            // @TODO: Needed PMREM\n\n            irradianceTextureUVNode = equirectUV(transformedNormalWorld);\n            irradianceTextureUVNode = vec2(irradianceTextureUVNode.x, irradianceTextureUVNode.y.oneMinus());\n          }\n          node = irradianceTextureUVNode;\n        }\n        return node;\n      },\n      getSamplerLevelNode: () => {\n        return float(1);\n      },\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {\n        return specularMIPLevel(textureNode, levelNode);\n      }\n    });\n\n    //\n\n    const isolateRadianceFlowContext = cache(radianceContext);\n\n    //\n\n    const intensity = reference('envMapIntensity', 'float', builder.material);\n    builder.context.radiance.addAssign(isolateRadianceFlowContext.mul(intensity));\n    builder.context.iblIrradiance.addAssign(irradianceContext.mul(Math.PI).mul(intensity));\n    properties.radianceContext = isolateRadianceFlowContext;\n    properties.irradianceContext = irradianceContext;\n  }\n}\nexport default EnvironmentNode;\naddNodeClass(EnvironmentNode);","map":{"version":3,"names":["LightingNode","cache","context","roughness","equirectUV","specularMIPLevel","cameraViewMatrix","transformedNormalView","transformedNormalWorld","positionViewDirection","addNodeClass","float","vec2","cubeTexture","reference","EnvironmentNode","constructor","envNode","arguments","length","undefined","construct","builder","properties","getNodeProperties","isTextureNode","value","isCubeTexture","texture","renderer","cubeRTT","getCubeRenderTarget","fromEquirectangularTexture","reflectVec","radianceTextureUVNode","irradianceTextureUVNode","radianceContext","getUVNode","textureNode","node","negate","reflect","mul","mix","normalize","transformDirection","isCubeTextureNode","getSamplerLevelNode","getMIPLevelAlgorithmNode","levelNode","irradianceContext","x","y","oneMinus","isolateRadianceFlowContext","intensity","material","radiance","addAssign","iblIrradiance","Math","PI"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\r\nimport { cache } from '../core/CacheNode.js';\r\nimport { context } from '../core/ContextNode.js';\r\nimport { roughness } from '../core/PropertyNode.js';\r\nimport { equirectUV } from '../utils/EquirectUVNode.js';\r\nimport { specularMIPLevel } from '../utils/SpecularMIPLevelNode.js';\r\nimport { cameraViewMatrix } from '../accessors/CameraNode.js';\r\nimport { transformedNormalView, transformedNormalWorld } from '../accessors/NormalNode.js';\r\nimport { positionViewDirection } from '../accessors/PositionNode.js';\r\nimport { addNodeClass } from '../core/Node.js';\r\nimport { float, vec2 } from '../shadernode/ShaderNode.js';\r\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\r\nimport { reference } from '../accessors/ReferenceNode.js';\r\n\r\nclass EnvironmentNode extends LightingNode {\r\n\r\n\tconstructor( envNode = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.envNode = envNode;\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\tlet envNode = this.envNode;\r\n\t\tconst properties = builder.getNodeProperties( this );\r\n\r\n\t\tif ( envNode.isTextureNode && envNode.value.isCubeTexture !== true ) {\r\n\r\n\t\t\tconst texture = envNode.value;\r\n\t\t\tconst renderer = builder.renderer;\r\n\r\n\t\t\t// @TODO: Add dispose logic here\r\n\t\t\tconst cubeRTT = builder.getCubeRenderTarget( 512 ).fromEquirectangularTexture( renderer, texture );\r\n\r\n\t\t\tenvNode = cubeTexture( cubeRTT.texture );\r\n\r\n\t\t}\r\n\r\n\t\tlet reflectVec;\r\n\t\tlet radianceTextureUVNode;\r\n\t\tlet irradianceTextureUVNode;\r\n\r\n\t\tconst radianceContext = context( envNode, {\r\n\t\t\tgetUVNode: ( textureNode ) => {\r\n\r\n\t\t\t\tlet node = null;\r\n\r\n\t\t\t\tif ( reflectVec === undefined ) {\r\n\r\n\t\t\t\t\treflectVec = positionViewDirection.negate().reflect( transformedNormalView );\r\n\t\t\t\t\treflectVec = roughness.mul( roughness ).mix( reflectVec, transformedNormalView ).normalize();\r\n\t\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( textureNode.isCubeTextureNode ) {\r\n\r\n\t\t\t\t\tnode = reflectVec;\r\n\r\n\t\t\t\t} else if ( textureNode.isTextureNode ) {\r\n\r\n\t\t\t\t\tif ( radianceTextureUVNode === undefined ) {\r\n\r\n\t\t\t\t\t\t// @TODO: Needed PMREM\r\n\r\n\t\t\t\t\t\tradianceTextureUVNode = equirectUV( reflectVec );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = radianceTextureUVNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t},\r\n\t\t\tgetSamplerLevelNode: () => {\r\n\r\n\t\t\t\treturn roughness;\r\n\r\n\t\t\t},\r\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {\r\n\r\n\t\t\t\treturn specularMIPLevel( textureNode, levelNode );\r\n\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\tconst irradianceContext = context( envNode, {\r\n\t\t\tgetUVNode: ( textureNode ) => {\r\n\r\n\t\t\t\tlet node = null;\r\n\r\n\t\t\t\tif ( textureNode.isCubeTextureNode ) {\r\n\r\n\t\t\t\t\tnode = transformedNormalWorld;\r\n\r\n\t\t\t\t} else if ( textureNode.isTextureNode ) {\r\n\r\n\t\t\t\t\tif ( irradianceTextureUVNode === undefined ) {\r\n\r\n\t\t\t\t\t\t// @TODO: Needed PMREM\r\n\r\n\t\t\t\t\t\tirradianceTextureUVNode = equirectUV( transformedNormalWorld );\r\n\t\t\t\t\t\tirradianceTextureUVNode = vec2( irradianceTextureUVNode.x, irradianceTextureUVNode.y.oneMinus() );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = irradianceTextureUVNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t},\r\n\t\t\tgetSamplerLevelNode: () => {\r\n\r\n\t\t\t\treturn float( 1 );\r\n\r\n\t\t\t},\r\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => {\r\n\r\n\t\t\t\treturn specularMIPLevel( textureNode, levelNode );\r\n\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\t//\r\n\r\n\t\tconst isolateRadianceFlowContext = cache( radianceContext );\r\n\r\n\t\t//\r\n\r\n\t\tconst intensity = reference( 'envMapIntensity', 'float', builder.material );\r\n\r\n\t\tbuilder.context.radiance.addAssign( isolateRadianceFlowContext.mul( intensity ) );\r\n\r\n\t\tbuilder.context.iblIrradiance.addAssign( irradianceContext.mul( Math.PI ).mul( intensity ) );\r\n\r\n\t\tproperties.radianceContext = isolateRadianceFlowContext;\r\n\t\tproperties.irradianceContext = irradianceContext;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default EnvironmentNode;\r\n\r\naddNodeClass( EnvironmentNode );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}