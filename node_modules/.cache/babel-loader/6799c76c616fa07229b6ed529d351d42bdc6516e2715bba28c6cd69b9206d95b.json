{"ast":null,"code":"import { GPUTextureViewDimension, GPUIndexFormat, GPUFilterMode, GPUPrimitiveTopology, GPULoadOp, GPUStoreOp } from './WebGPUConstants.js';\nclass WebGPUTextureMipmapUtils {\n  constructor(device) {\n    this.device = device;\n    const mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n    this.sampler = device.createSampler({\n      minFilter: GPUFilterMode.Linear\n    });\n\n    // We'll need a new pipeline for every texture format used.\n    this.pipelines = {};\n    this.mipmapVertexShaderModule = device.createShaderModule({\n      label: 'mipmapVertex',\n      code: mipmapVertexSource\n    });\n    this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: 'mipmapFragment',\n      code: mipmapFragmentSource\n    });\n  }\n  getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  generateMipmaps(textureGPU, textureGPUDescriptor) {\n    let baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const pipeline = this.getMipmapPipeline(textureGPUDescriptor.format);\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n    let srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {\n      const dstView = textureGPU.createView({\n        baseMipLevel: i,\n        mipLevelCount: 1,\n        dimension: GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: dstView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.sampler\n        }, {\n          binding: 1,\n          resource: srcView\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n      srcView = dstView;\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n  }\n}\nexport default WebGPUTextureMipmapUtils;","map":{"version":3,"names":["GPUTextureViewDimension","GPUIndexFormat","GPUFilterMode","GPUPrimitiveTopology","GPULoadOp","GPUStoreOp","WebGPUTextureMipmapUtils","constructor","device","mipmapVertexSource","mipmapFragmentSource","sampler","createSampler","minFilter","Linear","pipelines","mipmapVertexShaderModule","createShaderModule","label","code","mipmapFragmentShaderModule","getMipmapPipeline","format","pipeline","undefined","createRenderPipeline","vertex","module","entryPoint","fragment","targets","primitive","topology","TriangleStrip","stripIndexFormat","Uint32","layout","generateMipmaps","textureGPU","textureGPUDescriptor","baseArrayLayer","arguments","length","commandEncoder","createCommandEncoder","bindGroupLayout","getBindGroupLayout","srcView","createView","baseMipLevel","mipLevelCount","dimension","TwoD","i","dstView","passEncoder","beginRenderPass","colorAttachments","view","loadOp","Clear","storeOp","Store","clearValue","bindGroup","createBindGroup","entries","binding","resource","setPipeline","setBindGroup","draw","end","queue","submit","finish"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTextureMipmapUtils.js"],"sourcesContent":["import { GPUTextureViewDimension, GPUIndexFormat, GPUFilterMode, GPUPrimitiveTopology, GPULoadOp, GPUStoreOp } from './WebGPUConstants.js';\r\n\r\nclass WebGPUTextureMipmapUtils {\r\n\r\n\tconstructor( device ) {\r\n\r\n\t\tthis.device = device;\r\n\r\n\t\tconst mipmapVertexSource = `\r\nstruct VarysStruct {\r\n\t@builtin( position ) Position: vec4<f32>,\r\n\t@location( 0 ) vTex : vec2<f32>\r\n};\r\n\r\n@vertex\r\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\r\n\r\n\tvar Varys : VarysStruct;\r\n\r\n\tvar pos = array< vec2<f32>, 4 >(\r\n\t\tvec2<f32>( -1.0,  1.0 ),\r\n\t\tvec2<f32>(  1.0,  1.0 ),\r\n\t\tvec2<f32>( -1.0, -1.0 ),\r\n\t\tvec2<f32>(  1.0, -1.0 )\r\n\t);\r\n\r\n\tvar tex = array< vec2<f32>, 4 >(\r\n\t\tvec2<f32>( 0.0, 0.0 ),\r\n\t\tvec2<f32>( 1.0, 0.0 ),\r\n\t\tvec2<f32>( 0.0, 1.0 ),\r\n\t\tvec2<f32>( 1.0, 1.0 )\r\n\t);\r\n\r\n\tVarys.vTex = tex[ vertexIndex ];\r\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\r\n\r\n\treturn Varys;\r\n\r\n}\r\n`;\r\n\r\n\t\tconst mipmapFragmentSource = `\r\n@group( 0 ) @binding( 0 )\r\nvar imgSampler : sampler;\r\n\r\n@group( 0 ) @binding( 1 )\r\nvar img : texture_2d<f32>;\r\n\r\n@fragment\r\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\r\n\r\n\treturn textureSample( img, imgSampler, vTex );\r\n\r\n}\r\n`;\r\n\r\n\t\tthis.sampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\r\n\r\n\t\t// We'll need a new pipeline for every texture format used.\r\n\t\tthis.pipelines = {};\r\n\r\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\r\n\t\t\tlabel: 'mipmapVertex',\r\n\t\t\tcode: mipmapVertexSource\r\n\t\t} );\r\n\r\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\r\n\t\t\tlabel: 'mipmapFragment',\r\n\t\t\tcode: mipmapFragmentSource\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tgetMipmapPipeline( format ) {\r\n\r\n\t\tlet pipeline = this.pipelines[ format ];\r\n\r\n\t\tif ( pipeline === undefined ) {\r\n\r\n\t\t\tpipeline = this.device.createRenderPipeline( {\r\n\t\t\t\tvertex: {\r\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\r\n\t\t\t\t\tentryPoint: 'main'\r\n\t\t\t\t},\r\n\t\t\t\tfragment: {\r\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\r\n\t\t\t\t\tentryPoint: 'main',\r\n\t\t\t\t\ttargets: [ { format } ]\r\n\t\t\t\t},\r\n\t\t\t\tprimitive: {\r\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\r\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\r\n\t\t\t\t},\r\n\t\t\t\tlayout: 'auto'\r\n\t\t\t} );\r\n\r\n\t\t\tthis.pipelines[ format ] = pipeline;\r\n\r\n\t\t}\r\n\r\n\t\treturn pipeline;\r\n\r\n\t}\r\n\r\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\r\n\r\n\t\tconst pipeline = this.getMipmapPipeline( textureGPUDescriptor.format );\r\n\r\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\r\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\r\n\r\n\t\tlet srcView = textureGPU.createView( {\r\n\t\t\tbaseMipLevel: 0,\r\n\t\t\tmipLevelCount: 1,\r\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\r\n\t\t\tbaseArrayLayer\r\n\t\t} );\r\n\r\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\r\n\r\n\t\t\tconst dstView = textureGPU.createView( {\r\n\t\t\t\tbaseMipLevel: i,\r\n\t\t\t\tmipLevelCount: 1,\r\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\r\n\t\t\t\tbaseArrayLayer\r\n\t\t\t} );\r\n\r\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\r\n\t\t\t\tcolorAttachments: [ {\r\n\t\t\t\t\tview: dstView,\r\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\r\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\r\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\r\n\t\t\t\t} ]\r\n\t\t\t} );\r\n\r\n\t\t\tconst bindGroup = this.device.createBindGroup( {\r\n\t\t\t\tlayout: bindGroupLayout,\r\n\t\t\t\tentries: [ {\r\n\t\t\t\t\tbinding: 0,\r\n\t\t\t\t\tresource: this.sampler\r\n\t\t\t\t}, {\r\n\t\t\t\t\tbinding: 1,\r\n\t\t\t\t\tresource: srcView\r\n\t\t\t\t} ]\r\n\t\t\t} );\r\n\r\n\t\t\tpassEncoder.setPipeline( pipeline );\r\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\r\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\r\n\t\t\tpassEncoder.end();\r\n\r\n\t\t\tsrcView = dstView;\r\n\r\n\t\t}\r\n\r\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WebGPUTextureMipmapUtils;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}