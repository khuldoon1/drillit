{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { bypass } from '../core/BypassNode.js';\nimport { context as contextNode } from '../core/ContextNode.js';\nimport { addNodeElement, nodeObject, nodeArray } from '../shadernode/ShaderNode.js';\nclass LoopNode extends Node {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.params = params;\n  }\n  getVarName(index) {\n    return String.fromCharCode('i'.charCodeAt() + index);\n  }\n  getProperties(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.stackNode !== undefined) return properties;\n\n    //\n\n    const inputs = {};\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      const prop = this.getVarName(i);\n      inputs[prop] = expression(prop, 'int');\n    }\n    properties.returnsNode = this.params[this.params.length - 1].call(inputs, builder.addStack(), builder);\n    properties.stackNode = builder.removeStack();\n    return properties;\n  }\n  getNodeType(builder) {\n    const {\n      returnsNode\n    } = this.getProperties(builder);\n    return returnsNode ? returnsNode.getNodeType(builder) : 'void';\n  }\n  construct(builder) {\n    // construct properties\n\n    this.getProperties(builder);\n  }\n  generate(builder) {\n    const properties = this.getProperties(builder);\n    const context = {\n      tempWrite: false\n    };\n    const params = this.params;\n    const stackNode = properties.stackNode;\n    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';\n    for (let i = 0, l = params.length - 1; i < l; i++) {\n      const param = params[i];\n      const property = this.getVarName(i);\n      let start = null,\n        end = null,\n        direction = null;\n      if (param.isNode) {\n        start = '0';\n        end = param.generate(builder, 'int');\n        direction = 'forward';\n      } else {\n        start = param.start;\n        end = param.end;\n        direction = param.direction;\n        if (typeof start === 'number') start = start.toString();else if (start && start.isNode) start = start.generate(builder, 'int');\n        if (typeof end === 'number') end = end.toString();else if (end && end.isNode) end = end.generate(builder, 'int');\n        if (start !== undefined && end === undefined) {\n          start = start + ' - 1';\n          end = '0';\n          direction = 'backwards';\n        } else if (end !== undefined && start === undefined) {\n          start = '0';\n          direction = 'forward';\n        }\n        if (direction === undefined) {\n          if (Number(start) > Number(end)) {\n            direction = 'backwards';\n          } else {\n            direction = 'forward';\n          }\n        }\n      }\n      const internalParam = {\n        start,\n        end,\n        direction\n      };\n\n      //\n\n      const startSnippet = internalParam.start;\n      const endSnippet = internalParam.end;\n      let declarationSnippet = '';\n      let conditionalSnippet = '';\n      let updateSnippet = '';\n      declarationSnippet += builder.getVar('int', property) + ' = ' + startSnippet;\n      if (internalParam.direction === 'backwards') {\n        conditionalSnippet += property + ' >= ' + endSnippet;\n        updateSnippet += property + ' --';\n      } else {\n        // forward\n\n        conditionalSnippet += property + ' < ' + endSnippet;\n        updateSnippet += property + ' ++';\n      }\n      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      builder.addFlowCode((i === 0 ? '\\n' : '') + builder.tab + forSnippet + ' {\\n\\n').addFlowTab();\n    }\n    const stackSnippet = contextNode(stackNode, context).build(builder, 'void');\n    builder.removeFlowTab().addFlowCode('\\n' + builder.tab + stackSnippet);\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\\n\\n').removeFlowTab();\n    }\n    builder.addFlowTab();\n    return returnsSnippet;\n  }\n}\nexport default LoopNode;\nexport const loop = function () {\n  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n  return nodeObject(new LoopNode(nodeArray(params, 'int')));\n};\naddNodeElement('loop', function (returns) {\n  for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    params[_key2 - 1] = arguments[_key2];\n  }\n  return bypass(returns, loop(...params));\n});\naddNodeClass(LoopNode);","map":{"version":3,"names":["Node","addNodeClass","expression","bypass","context","contextNode","addNodeElement","nodeObject","nodeArray","LoopNode","constructor","params","arguments","length","undefined","getVarName","index","String","fromCharCode","charCodeAt","getProperties","builder","properties","getNodeProperties","stackNode","inputs","i","l","prop","returnsNode","call","addStack","removeStack","getNodeType","construct","generate","tempWrite","returnsSnippet","build","param","property","start","end","direction","isNode","toString","Number","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","getVar","forSnippet","addFlowCode","tab","addFlowTab","stackSnippet","removeFlowTab","loop","_len","Array","_key","returns","_len2","_key2"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/utils/LoopNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\r\nimport { expression } from '../code/ExpressionNode.js';\r\nimport { bypass } from '../core/BypassNode.js';\r\nimport { context as contextNode } from '../core/ContextNode.js';\r\nimport { addNodeElement, nodeObject, nodeArray } from '../shadernode/ShaderNode.js';\r\n\r\nclass LoopNode extends Node {\r\n\r\n\tconstructor( params = [] ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.params = params;\r\n\r\n\t}\r\n\r\n\tgetVarName( index ) {\r\n\r\n\t\treturn String.fromCharCode( 'i'.charCodeAt() + index );\r\n\r\n\t}\r\n\r\n\tgetProperties( builder ) {\r\n\r\n\t\tconst properties = builder.getNodeProperties( this );\r\n\r\n\t\tif ( properties.stackNode !== undefined ) return properties;\r\n\r\n\t\t//\r\n\r\n\t\tconst inputs = {};\r\n\r\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\r\n\r\n\t\t\tconst prop = this.getVarName( i );\r\n\r\n\t\t\tinputs[ prop ] = expression( prop, 'int' );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ].call( inputs, builder.addStack(), builder );\r\n\t\tproperties.stackNode = builder.removeStack();\r\n\r\n\t\treturn properties;\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst { returnsNode } = this.getProperties( builder );\r\n\r\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\t// construct properties\r\n\r\n\t\tthis.getProperties( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst properties = this.getProperties( builder );\r\n\r\n\t\tconst context = { tempWrite: false };\r\n\r\n\t\tconst params = this.params;\r\n\t\tconst stackNode = properties.stackNode;\r\n\r\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\r\n\r\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\r\n\r\n\t\t\tconst param = params[ i ];\r\n\t\t\tconst property = this.getVarName( i );\r\n\r\n\t\t\tlet start = null, end = null, direction = null;\r\n\r\n\t\t\tif ( param.isNode ) {\r\n\r\n\t\t\t\tstart = '0';\r\n\t\t\t\tend = param.generate( builder, 'int' );\r\n\t\t\t\tdirection = 'forward';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstart = param.start;\r\n\t\t\t\tend = param.end;\r\n\t\t\t\tdirection = param.direction;\r\n\r\n\t\t\t\tif ( typeof start === 'number' ) start = start.toString();\r\n\t\t\t\telse if ( start && start.isNode ) start = start.generate( builder, 'int' );\r\n\r\n\t\t\t\tif ( typeof end === 'number' ) end = end.toString();\r\n\t\t\t\telse if ( end && end.isNode ) end = end.generate( builder, 'int' );\r\n\r\n\t\t\t\tif ( start !== undefined && end === undefined ) {\r\n\r\n\t\t\t\t\tstart = start + ' - 1';\r\n\t\t\t\t\tend = '0';\r\n\t\t\t\t\tdirection = 'backwards';\r\n\r\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\r\n\r\n\t\t\t\t\tstart = '0';\r\n\t\t\t\t\tdirection = 'forward';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( direction === undefined ) {\r\n\r\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\r\n\r\n\t\t\t\t\t\tdirection = 'backwards';\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdirection = 'forward';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst internalParam = { start, end, direction };\r\n\r\n\t\t\t//\r\n\r\n\t\t\tconst startSnippet = internalParam.start;\r\n\t\t\tconst endSnippet = internalParam.end;\r\n\r\n\t\t\tlet declarationSnippet = '';\r\n\t\t\tlet conditionalSnippet = '';\r\n\t\t\tlet updateSnippet = '';\r\n\r\n\t\t\tdeclarationSnippet += builder.getVar( 'int', property ) + ' = ' + startSnippet;\r\n\r\n\t\t\tif ( internalParam.direction === 'backwards' ) {\r\n\r\n\t\t\t\tconditionalSnippet += property + ' >= ' + endSnippet;\r\n\t\t\t\tupdateSnippet += property + ' --';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// forward\r\n\r\n\t\t\t\tconditionalSnippet += property + ' < ' + endSnippet;\r\n\t\t\t\tupdateSnippet += property + ' ++';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\r\n\r\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\r\n\r\n\t\t}\r\n\r\n\t\tconst stackSnippet = contextNode( stackNode, context ).build( builder, 'void' );\r\n\r\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\r\n\r\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\r\n\r\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\r\n\r\n\t\t}\r\n\r\n\t\tbuilder.addFlowTab();\r\n\r\n\t\treturn returnsSnippet;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default LoopNode;\r\n\r\nexport const loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) );\r\n\r\naddNodeElement( 'loop', ( returns, ...params ) => bypass( returns, loop( ...params ) ) );\r\n\r\naddNodeClass( LoopNode );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}