{"ast":null,"code":"import Node, { addNodeClass } from './Node.js';\nimport { NodeShaderStage } from './constants.js';\nimport { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';\nclass VaryingNode extends Node {\n  constructor(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.node = node;\n    this.name = name;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    // VaryingNode is auto type\n\n    return this.node.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      name,\n      node\n    } = this;\n    const type = this.getNodeType(builder);\n    const nodeVarying = builder.getVaryingFromNode(this, type);\n\n    // this property can be used to check if the varying can be optimized for a var\n    nodeVarying.needsInterpolation || (nodeVarying.needsInterpolation = builder.shaderStage === 'fragment');\n    if (name !== null) {\n      nodeVarying.name = name;\n    }\n    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.VERTEX);\n\n    // force node run in vertex stage\n    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, node, type, propertyName);\n    return builder.getPropertyName(nodeVarying);\n  }\n}\nexport default VaryingNode;\nexport const varying = nodeProxy(VaryingNode);\naddNodeElement('varying', varying);\naddNodeClass(VaryingNode);","map":{"version":3,"names":["Node","addNodeClass","NodeShaderStage","addNodeElement","nodeProxy","VaryingNode","constructor","node","name","arguments","length","undefined","isGlobal","getHash","builder","getNodeType","generate","type","nodeVarying","getVaryingFromNode","needsInterpolation","shaderStage","propertyName","getPropertyName","VERTEX","flowNodeFromShaderStage","varying"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/core/VaryingNode.js"],"sourcesContent":["import Node, { addNodeClass } from './Node.js';\r\nimport { NodeShaderStage } from './constants.js';\r\nimport { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';\r\n\r\nclass VaryingNode extends Node {\r\n\r\n\tconstructor( node, name = null ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.node = node;\r\n\t\tthis.name = name;\r\n\r\n\t}\r\n\r\n\tisGlobal() {\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tgetHash( builder ) {\r\n\r\n\t\treturn this.name || super.getHash( builder );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\t// VaryingNode is auto type\r\n\r\n\t\treturn this.node.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tgenerate( builder ) {\r\n\r\n\t\tconst { name, node } = this;\r\n\t\tconst type = this.getNodeType( builder );\r\n\r\n\t\tconst nodeVarying = builder.getVaryingFromNode( this, type );\r\n\r\n\t\t// this property can be used to check if the varying can be optimized for a var\r\n\t\tnodeVarying.needsInterpolation || ( nodeVarying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\r\n\r\n\t\tif ( name !== null ) {\r\n\r\n\t\t\tnodeVarying.name = name;\r\n\r\n\t\t}\r\n\r\n\t\tconst propertyName = builder.getPropertyName( nodeVarying, NodeShaderStage.VERTEX );\r\n\r\n\t\t// force node run in vertex stage\r\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, node, type, propertyName );\r\n\r\n\t\treturn builder.getPropertyName( nodeVarying );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default VaryingNode;\r\n\r\nexport const varying = nodeProxy( VaryingNode );\r\n\r\naddNodeElement( 'varying', varying );\r\n\r\naddNodeClass( VaryingNode );\r\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,WAAW;AAC9C,SAASC,eAAe,QAAQ,gBAAgB;AAChD,SAASC,cAAc,EAAEC,SAAS,QAAQ,6BAA6B;AAEvE,MAAMC,WAAW,SAASL,IAAI,CAAC;EAE9BM,WAAWA,CAAEC,IAAI,EAAgB;IAAA,IAAdC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAE7B,KAAK,CAAC,CAAC;IAEP,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;EAEjB;EAEAI,QAAQA,CAAA,EAAG;IAEV,OAAO,IAAI;EAEZ;EAEAC,OAAOA,CAAEC,OAAO,EAAG;IAElB,OAAO,IAAI,CAACN,IAAI,IAAI,KAAK,CAACK,OAAO,CAAEC,OAAQ,CAAC;EAE7C;EAEAC,WAAWA,CAAED,OAAO,EAAG;IAEtB;;IAEA,OAAO,IAAI,CAACP,IAAI,CAACQ,WAAW,CAAED,OAAQ,CAAC;EAExC;EAEAE,QAAQA,CAAEF,OAAO,EAAG;IAEnB,MAAM;MAAEN,IAAI;MAAED;IAAK,CAAC,GAAG,IAAI;IAC3B,MAAMU,IAAI,GAAG,IAAI,CAACF,WAAW,CAAED,OAAQ,CAAC;IAExC,MAAMI,WAAW,GAAGJ,OAAO,CAACK,kBAAkB,CAAE,IAAI,EAAEF,IAAK,CAAC;;IAE5D;IACAC,WAAW,CAACE,kBAAkB,KAAMF,WAAW,CAACE,kBAAkB,GAAKN,OAAO,CAACO,WAAW,KAAK,UAAY,CAAE;IAE7G,IAAKb,IAAI,KAAK,IAAI,EAAG;MAEpBU,WAAW,CAACV,IAAI,GAAGA,IAAI;IAExB;IAEA,MAAMc,YAAY,GAAGR,OAAO,CAACS,eAAe,CAAEL,WAAW,EAAEhB,eAAe,CAACsB,MAAO,CAAC;;IAEnF;IACAV,OAAO,CAACW,uBAAuB,CAAEvB,eAAe,CAACsB,MAAM,EAAEjB,IAAI,EAAEU,IAAI,EAAEK,YAAa,CAAC;IAEnF,OAAOR,OAAO,CAACS,eAAe,CAAEL,WAAY,CAAC;EAE9C;AAED;AAEA,eAAeb,WAAW;AAE1B,OAAO,MAAMqB,OAAO,GAAGtB,SAAS,CAAEC,WAAY,CAAC;AAE/CF,cAAc,CAAE,SAAS,EAAEuB,OAAQ,CAAC;AAEpCzB,YAAY,CAAEI,WAAY,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}