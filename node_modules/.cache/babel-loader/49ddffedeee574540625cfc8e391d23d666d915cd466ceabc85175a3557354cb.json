{"ast":null,"code":"import { code } from '../../code/CodeNode.js';\nimport { fn } from '../../code/FunctionNode.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\nexport const mx_noise = code(`float mx_select(bool b, float t, float f)\n{\n    return b ? t : f;\n}\n\nfloat mx_negate_if(float val, bool b)\n{\n    return b ? -val : val;\n}\n\nint mx_floor(float x)\n{\n    return int(floor(x));\n}\n\n// return mx_floor as well as the fractional remainder\nfloat mx_floorfrac(float x, out int i)\n{\n    i = mx_floor(x);\n    return x - float(i);\n}\n\nfloat mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nvec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nfloat mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\nvec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\n\n// 2 and 3 dimensional gradient functions - perform a dot product against a\n// randomly chosen vector. Note that the gradient vector is not normalized, but\n// this only affects the overal \"scale\" of the result, so we simply account for\n// the scale by multiplying in the corresponding \"perlin\" function.\nfloat mx_gradient_float(uint hash, float x, float y)\n{\n    // 8 possible directions (+-1,+-2) and (+-2,+-1)\n    uint h = hash & 7u;\n    float u = mx_select(h<4u, x, y);\n    float v = 2.0 * mx_select(h<4u, y, x);\n    // compute the dot product with (x,y).\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nfloat mx_gradient_float(uint hash, float x, float y, float z)\n{\n    // use vectors pointing to the edges of the cube\n    uint h = hash & 15u;\n    float u = mx_select(h<8u, x, y);\n    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y)\n{\n    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)\n{\n    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}\n// Scaling factors to normalize the result of gradients above.\n// These factors were experimentally calculated to be:\n//    2D:   0.6616\n//    3D:   0.9820\nfloat mx_gradient_scale2d(float v) { return 0.6616 * v; }\nfloat mx_gradient_scale3d(float v) { return 0.9820 * v; }\nvec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }\nvec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }\n\n/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)\nuint mx_rotl32(uint x, int k)\n{\n    return (x<<k) | (x>>(32-k));\n}\n\nvoid mx_bjmix(inout uint a, inout uint b, inout uint c)\n{\n    a -= c; a ^= mx_rotl32(c, 4); c += b;\n    b -= a; b ^= mx_rotl32(a, 6); a += c;\n    c -= b; c ^= mx_rotl32(b, 8); b += a;\n    a -= c; a ^= mx_rotl32(c,16); c += b;\n    b -= a; b ^= mx_rotl32(a,19); a += c;\n    c -= b; c ^= mx_rotl32(b, 4); b += a;\n}\n\n// Mix up and combine the bits of a, b, and c (doesn't change them, but\n// returns a hash of those three original values).\nuint mx_bjfinal(uint a, uint b, uint c)\n{\n    c ^= b; c -= mx_rotl32(b,14);\n    a ^= c; a -= mx_rotl32(c,11);\n    b ^= a; b -= mx_rotl32(a,25);\n    c ^= b; c -= mx_rotl32(b,16);\n    a ^= c; a -= mx_rotl32(c,4);\n    b ^= a; b -= mx_rotl32(a,14);\n    c ^= b; c -= mx_rotl32(b,24);\n    return c;\n}\n\n// Convert a 32 bit integer into a floating point number in [0,1]\nfloat mx_bits_to_01(uint bits)\n{\n    return float(bits) / float(uint(0xffffffff));\n}\n\nfloat mx_fade(float t)\n{\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nuint mx_hash_int(int x)\n{\n    uint len = 1u;\n    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;\n    return mx_bjfinal(seed+uint(x), seed, seed);\n}\n\nuint mx_hash_int(int x, int y)\n{\n    uint len = 2u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z)\n{\n    uint len = 3u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx)\n{\n    uint len = 4u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx, int yy)\n{\n    uint len = 5u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    b += uint(yy);\n    return mx_bjfinal(a, b, c);\n}\n\nuvec3 mx_hash_vec3(int x, int y)\n{\n    uint h = mx_hash_int(x, y);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nuvec3 mx_hash_vec3(int x, int y, int z)\n{\n    uint h = mx_hash_int(x, y, z);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nfloat mx_perlin_noise_float(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float result = mx_bilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nfloat mx_perlin_noise_float(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    float result = mx_trilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    vec3 result = mx_bilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    vec3 result = mx_trilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nfloat mx_cell_noise_float(float p)\n{\n    int ix = mx_floor(p);\n    return mx_bits_to_01(mx_hash_int(ix));\n}\n\nfloat mx_cell_noise_float(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return mx_bits_to_01(mx_hash_int(ix, iy));\n}\n\nfloat mx_cell_noise_float(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}\n\nfloat mx_cell_noise_float(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}\n\nvec3 mx_cell_noise_vec3(float p)\n{\n    int ix = mx_floor(p);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, 0)),\n            mx_bits_to_01(mx_hash_int(ix, 1)),\n            mx_bits_to_01(mx_hash_int(ix, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))\n    );\n}\n\nfloat mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    float result = 0.0;\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_float(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3 result = vec3(0.0);\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_vec3(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),\n                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));\n}\n\nvec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);\n    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);\n    return vec4(c, f);\n}\n\nfloat mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)\n{\n    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));\n    vec2  off = vec2(tmp.x, tmp.y);\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec2 cellpos = vec2(float(x), float(y)) + off;\n    vec2 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y);       // Manhattan distance\n    if (metric == 3)\n        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)\n{\n    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;\n    vec3 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance\n    if (metric == 3)\n        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_noise_float(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            sqdist = min(sqdist, dist);\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.y = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = dist;\n            }\n            else if (dist < sqdist.z)\n            {\n                sqdist.z = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nfloat mx_worley_noise_float(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    float sqdist = 1e6f;\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                sqdist = min(sqdist, dist);\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.y = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = dist;\n                }\n                else if (dist < sqdist.z)\n                {\n                    sqdist.z = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}`);\nconst includes = [mx_noise];\nexport const mx_perlin_noise_float = fn('float mx_perlin_noise_float( any p )', includes);\nexport const mx_perlin_noise_vec2 = fn('vec2 mx_perlin_noise_vec2( any p )', includes);\nexport const mx_perlin_noise_vec3 = fn('vec3 mx_perlin_noise_vec3( any p )', includes);\nexport const mx_cell_noise_float = fn('float mx_cell_noise_float( vec3 p )', includes);\nexport const mx_worley_noise_float = fn('float mx_worley_noise_float( any p, float jitter, int metric )', includes);\nexport const mx_worley_noise_vec2 = fn('float mx_worley_noise_vec2( any p, float jitter, int metric )', includes);\nexport const mx_worley_noise_vec3 = fn('float mx_worley_noise_vec3( any p, float jitter, int metric )', includes);\nexport const mx_fractal_noise_float = fn('float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )', includes);\nexport const mx_fractal_noise_vec2 = fn('float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )', includes);\nexport const mx_fractal_noise_vec3 = fn('float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )', includes);\nexport const mx_fractal_noise_vec4 = fn('float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )', includes);","map":{"version":3,"names":["code","fn","mx_noise","includes","mx_perlin_noise_float","mx_perlin_noise_vec2","mx_perlin_noise_vec3","mx_cell_noise_float","mx_worley_noise_float","mx_worley_noise_vec2","mx_worley_noise_vec3","mx_fractal_noise_float","mx_fractal_noise_vec2","mx_fractal_noise_vec3","mx_fractal_noise_vec4"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js"],"sourcesContent":["import { code } from '../../code/CodeNode.js';\r\nimport { fn } from '../../code/FunctionNode.js';\r\n\r\n// Original shader code from:\r\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\r\n\r\nexport const mx_noise = code( `float mx_select(bool b, float t, float f)\r\n{\r\n    return b ? t : f;\r\n}\r\n\r\nfloat mx_negate_if(float val, bool b)\r\n{\r\n    return b ? -val : val;\r\n}\r\n\r\nint mx_floor(float x)\r\n{\r\n    return int(floor(x));\r\n}\r\n\r\n// return mx_floor as well as the fractional remainder\r\nfloat mx_floorfrac(float x, out int i)\r\n{\r\n    i = mx_floor(x);\r\n    return x - float(i);\r\n}\r\n\r\nfloat mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)\r\n{\r\n    float s1 = 1.0 - s;\r\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\r\n}\r\nvec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)\r\n{\r\n    float s1 = 1.0 - s;\r\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\r\n}\r\nfloat mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)\r\n{\r\n    float s1 = 1.0 - s;\r\n    float t1 = 1.0 - t;\r\n    float r1 = 1.0 - r;\r\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\r\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\r\n}\r\nvec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)\r\n{\r\n    float s1 = 1.0 - s;\r\n    float t1 = 1.0 - t;\r\n    float r1 = 1.0 - r;\r\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\r\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\r\n}\r\n\r\n// 2 and 3 dimensional gradient functions - perform a dot product against a\r\n// randomly chosen vector. Note that the gradient vector is not normalized, but\r\n// this only affects the overal \"scale\" of the result, so we simply account for\r\n// the scale by multiplying in the corresponding \"perlin\" function.\r\nfloat mx_gradient_float(uint hash, float x, float y)\r\n{\r\n    // 8 possible directions (+-1,+-2) and (+-2,+-1)\r\n    uint h = hash & 7u;\r\n    float u = mx_select(h<4u, x, y);\r\n    float v = 2.0 * mx_select(h<4u, y, x);\r\n    // compute the dot product with (x,y).\r\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\r\n}\r\nfloat mx_gradient_float(uint hash, float x, float y, float z)\r\n{\r\n    // use vectors pointing to the edges of the cube\r\n    uint h = hash & 15u;\r\n    float u = mx_select(h<8u, x, y);\r\n    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));\r\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\r\n}\r\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y)\r\n{\r\n    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\r\n}\r\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)\r\n{\r\n    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\r\n}\r\n// Scaling factors to normalize the result of gradients above.\r\n// These factors were experimentally calculated to be:\r\n//    2D:   0.6616\r\n//    3D:   0.9820\r\nfloat mx_gradient_scale2d(float v) { return 0.6616 * v; }\r\nfloat mx_gradient_scale3d(float v) { return 0.9820 * v; }\r\nvec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }\r\nvec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }\r\n\r\n/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)\r\nuint mx_rotl32(uint x, int k)\r\n{\r\n    return (x<<k) | (x>>(32-k));\r\n}\r\n\r\nvoid mx_bjmix(inout uint a, inout uint b, inout uint c)\r\n{\r\n    a -= c; a ^= mx_rotl32(c, 4); c += b;\r\n    b -= a; b ^= mx_rotl32(a, 6); a += c;\r\n    c -= b; c ^= mx_rotl32(b, 8); b += a;\r\n    a -= c; a ^= mx_rotl32(c,16); c += b;\r\n    b -= a; b ^= mx_rotl32(a,19); a += c;\r\n    c -= b; c ^= mx_rotl32(b, 4); b += a;\r\n}\r\n\r\n// Mix up and combine the bits of a, b, and c (doesn't change them, but\r\n// returns a hash of those three original values).\r\nuint mx_bjfinal(uint a, uint b, uint c)\r\n{\r\n    c ^= b; c -= mx_rotl32(b,14);\r\n    a ^= c; a -= mx_rotl32(c,11);\r\n    b ^= a; b -= mx_rotl32(a,25);\r\n    c ^= b; c -= mx_rotl32(b,16);\r\n    a ^= c; a -= mx_rotl32(c,4);\r\n    b ^= a; b -= mx_rotl32(a,14);\r\n    c ^= b; c -= mx_rotl32(b,24);\r\n    return c;\r\n}\r\n\r\n// Convert a 32 bit integer into a floating point number in [0,1]\r\nfloat mx_bits_to_01(uint bits)\r\n{\r\n    return float(bits) / float(uint(0xffffffff));\r\n}\r\n\r\nfloat mx_fade(float t)\r\n{\r\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r\n}\r\n\r\nuint mx_hash_int(int x)\r\n{\r\n    uint len = 1u;\r\n    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;\r\n    return mx_bjfinal(seed+uint(x), seed, seed);\r\n}\r\n\r\nuint mx_hash_int(int x, int y)\r\n{\r\n    uint len = 2u;\r\n    uint a, b, c;\r\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\r\n    a += uint(x);\r\n    b += uint(y);\r\n    return mx_bjfinal(a, b, c);\r\n}\r\n\r\nuint mx_hash_int(int x, int y, int z)\r\n{\r\n    uint len = 3u;\r\n    uint a, b, c;\r\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\r\n    a += uint(x);\r\n    b += uint(y);\r\n    c += uint(z);\r\n    return mx_bjfinal(a, b, c);\r\n}\r\n\r\nuint mx_hash_int(int x, int y, int z, int xx)\r\n{\r\n    uint len = 4u;\r\n    uint a, b, c;\r\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\r\n    a += uint(x);\r\n    b += uint(y);\r\n    c += uint(z);\r\n    mx_bjmix(a, b, c);\r\n    a += uint(xx);\r\n    return mx_bjfinal(a, b, c);\r\n}\r\n\r\nuint mx_hash_int(int x, int y, int z, int xx, int yy)\r\n{\r\n    uint len = 5u;\r\n    uint a, b, c;\r\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\r\n    a += uint(x);\r\n    b += uint(y);\r\n    c += uint(z);\r\n    mx_bjmix(a, b, c);\r\n    a += uint(xx);\r\n    b += uint(yy);\r\n    return mx_bjfinal(a, b, c);\r\n}\r\n\r\nuvec3 mx_hash_vec3(int x, int y)\r\n{\r\n    uint h = mx_hash_int(x, y);\r\n    // we only need the low-order bits to be random, so split out\r\n    // the 32 bit result into 3 parts for each channel\r\n    uvec3 result;\r\n    result.x = (h      ) & 0xFFu;\r\n    result.y = (h >> 8 ) & 0xFFu;\r\n    result.z = (h >> 16) & 0xFFu;\r\n    return result;\r\n}\r\n\r\nuvec3 mx_hash_vec3(int x, int y, int z)\r\n{\r\n    uint h = mx_hash_int(x, y, z);\r\n    // we only need the low-order bits to be random, so split out\r\n    // the 32 bit result into 3 parts for each channel\r\n    uvec3 result;\r\n    result.x = (h      ) & 0xFFu;\r\n    result.y = (h >> 8 ) & 0xFFu;\r\n    result.z = (h >> 16) & 0xFFu;\r\n    return result;\r\n}\r\n\r\nfloat mx_perlin_noise_float(vec2 p)\r\n{\r\n    int X, Y;\r\n    float fx = mx_floorfrac(p.x, X);\r\n    float fy = mx_floorfrac(p.y, Y);\r\n    float u = mx_fade(fx);\r\n    float v = mx_fade(fy);\r\n    float result = mx_bilerp(\r\n        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),\r\n        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),\r\n        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),\r\n        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),\r\n        u, v);\r\n    return mx_gradient_scale2d(result);\r\n}\r\n\r\nfloat mx_perlin_noise_float(vec3 p)\r\n{\r\n    int X, Y, Z;\r\n    float fx = mx_floorfrac(p.x, X);\r\n    float fy = mx_floorfrac(p.y, Y);\r\n    float fz = mx_floorfrac(p.z, Z);\r\n    float u = mx_fade(fx);\r\n    float v = mx_fade(fy);\r\n    float w = mx_fade(fz);\r\n    float result = mx_trilerp(\r\n        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),\r\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\r\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\r\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\r\n        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),\r\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\r\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\r\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\r\n        u, v, w);\r\n    return mx_gradient_scale3d(result);\r\n}\r\n\r\nvec3 mx_perlin_noise_vec3(vec2 p)\r\n{\r\n    int X, Y;\r\n    float fx = mx_floorfrac(p.x, X);\r\n    float fy = mx_floorfrac(p.y, Y);\r\n    float u = mx_fade(fx);\r\n    float v = mx_fade(fy);\r\n    vec3 result = mx_bilerp(\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),\r\n        u, v);\r\n    return mx_gradient_scale2d(result);\r\n}\r\n\r\nvec3 mx_perlin_noise_vec3(vec3 p)\r\n{\r\n    int X, Y, Z;\r\n    float fx = mx_floorfrac(p.x, X);\r\n    float fy = mx_floorfrac(p.y, Y);\r\n    float fz = mx_floorfrac(p.z, Z);\r\n    float u = mx_fade(fx);\r\n    float v = mx_fade(fy);\r\n    float w = mx_fade(fz);\r\n    vec3 result = mx_trilerp(\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\r\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\r\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\r\n        u, v, w);\r\n    return mx_gradient_scale3d(result);\r\n}\r\n\r\nfloat mx_cell_noise_float(float p)\r\n{\r\n    int ix = mx_floor(p);\r\n    return mx_bits_to_01(mx_hash_int(ix));\r\n}\r\n\r\nfloat mx_cell_noise_float(vec2 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    return mx_bits_to_01(mx_hash_int(ix, iy));\r\n}\r\n\r\nfloat mx_cell_noise_float(vec3 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    int iz = mx_floor(p.z);\r\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz));\r\n}\r\n\r\nfloat mx_cell_noise_float(vec4 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    int iz = mx_floor(p.z);\r\n    int iw = mx_floor(p.w);\r\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\r\n}\r\n\r\nvec3 mx_cell_noise_vec3(float p)\r\n{\r\n    int ix = mx_floor(p);\r\n    return vec3(\r\n            mx_bits_to_01(mx_hash_int(ix, 0)),\r\n            mx_bits_to_01(mx_hash_int(ix, 1)),\r\n            mx_bits_to_01(mx_hash_int(ix, 2))\r\n    );\r\n}\r\n\r\nvec3 mx_cell_noise_vec3(vec2 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    return vec3(\r\n            mx_bits_to_01(mx_hash_int(ix, iy, 0)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, 1)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, 2))\r\n    );\r\n}\r\n\r\nvec3 mx_cell_noise_vec3(vec3 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    int iz = mx_floor(p.z);\r\n    return vec3(\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))\r\n    );\r\n}\r\n\r\nvec3 mx_cell_noise_vec3(vec4 p)\r\n{\r\n    int ix = mx_floor(p.x);\r\n    int iy = mx_floor(p.y);\r\n    int iz = mx_floor(p.z);\r\n    int iw = mx_floor(p.w);\r\n    return vec3(\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),\r\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))\r\n    );\r\n}\r\n\r\nfloat mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)\r\n{\r\n    float result = 0.0;\r\n    float amplitude = 1.0;\r\n    for (int i = 0;  i < octaves; ++i)\r\n    {\r\n        result += amplitude * mx_perlin_noise_float(p);\r\n        amplitude *= diminish;\r\n        p *= lacunarity;\r\n    }\r\n    return result;\r\n}\r\n\r\nvec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)\r\n{\r\n    vec3 result = vec3(0.0);\r\n    float amplitude = 1.0;\r\n    for (int i = 0;  i < octaves; ++i)\r\n    {\r\n        result += amplitude * mx_perlin_noise_vec3(p);\r\n        amplitude *= diminish;\r\n        p *= lacunarity;\r\n    }\r\n    return result;\r\n}\r\n\r\nvec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)\r\n{\r\n    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),\r\n                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));\r\n}\r\n\r\nvec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)\r\n{\r\n    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);\r\n    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);\r\n    return vec4(c, f);\r\n}\r\n\r\nfloat mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)\r\n{\r\n    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));\r\n    vec2  off = vec2(tmp.x, tmp.y);\r\n\r\n    off -= 0.5f;\r\n    off *= jitter;\r\n    off += 0.5f;\r\n\r\n    vec2 cellpos = vec2(float(x), float(y)) + off;\r\n    vec2 diff = cellpos - p;\r\n    if (metric == 2)\r\n        return abs(diff.x) + abs(diff.y);       // Manhattan distance\r\n    if (metric == 3)\r\n        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance\r\n    // Either Euclidian or Distance^2\r\n    return dot(diff, diff);\r\n}\r\n\r\nfloat mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)\r\n{\r\n    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));\r\n\r\n    off -= 0.5f;\r\n    off *= jitter;\r\n    off += 0.5f;\r\n\r\n    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;\r\n    vec3 diff = cellpos - p;\r\n    if (metric == 2)\r\n        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance\r\n    if (metric == 3)\r\n        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance\r\n    // Either Euclidian or Distance^2\r\n    return dot(diff, diff);\r\n}\r\n\r\nfloat mx_worley_noise_float(vec2 p, float jitter, int metric)\r\n{\r\n    int X, Y;\r\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\r\n    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\r\n            sqdist = min(sqdist, dist);\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}\r\n\r\nvec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)\r\n{\r\n    int X, Y;\r\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\r\n    vec2 sqdist = vec2(1e6f, 1e6f);\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\r\n            if (dist < sqdist.x)\r\n            {\r\n                sqdist.y = sqdist.x;\r\n                sqdist.x = dist;\r\n            }\r\n            else if (dist < sqdist.y)\r\n            {\r\n                sqdist.y = dist;\r\n            }\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}\r\n\r\nvec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)\r\n{\r\n    int X, Y;\r\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\r\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\r\n            if (dist < sqdist.x)\r\n            {\r\n                sqdist.z = sqdist.y;\r\n                sqdist.y = sqdist.x;\r\n                sqdist.x = dist;\r\n            }\r\n            else if (dist < sqdist.y)\r\n            {\r\n                sqdist.z = sqdist.y;\r\n                sqdist.y = dist;\r\n            }\r\n            else if (dist < sqdist.z)\r\n            {\r\n                sqdist.z = dist;\r\n            }\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}\r\n\r\nfloat mx_worley_noise_float(vec3 p, float jitter, int metric)\r\n{\r\n    int X, Y, Z;\r\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\r\n    float sqdist = 1e6f;\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            for (int z = -1; z <= 1; ++z)\r\n            {\r\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\r\n                sqdist = min(sqdist, dist);\r\n            }\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}\r\n\r\nvec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)\r\n{\r\n    int X, Y, Z;\r\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\r\n    vec2 sqdist = vec2(1e6f, 1e6f);\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            for (int z = -1; z <= 1; ++z)\r\n            {\r\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\r\n                if (dist < sqdist.x)\r\n                {\r\n                    sqdist.y = sqdist.x;\r\n                    sqdist.x = dist;\r\n                }\r\n                else if (dist < sqdist.y)\r\n                {\r\n                    sqdist.y = dist;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}\r\n\r\nvec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)\r\n{\r\n    int X, Y, Z;\r\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\r\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\r\n    for (int x = -1; x <= 1; ++x)\r\n    {\r\n        for (int y = -1; y <= 1; ++y)\r\n        {\r\n            for (int z = -1; z <= 1; ++z)\r\n            {\r\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\r\n                if (dist < sqdist.x)\r\n                {\r\n                    sqdist.z = sqdist.y;\r\n                    sqdist.y = sqdist.x;\r\n                    sqdist.x = dist;\r\n                }\r\n                else if (dist < sqdist.y)\r\n                {\r\n                    sqdist.z = sqdist.y;\r\n                    sqdist.y = dist;\r\n                }\r\n                else if (dist < sqdist.z)\r\n                {\r\n                    sqdist.z = dist;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (metric == 0)\r\n        sqdist = sqrt(sqdist);\r\n    return sqdist;\r\n}` );\r\n\r\nconst includes = [ mx_noise ];\r\n\r\nexport const mx_perlin_noise_float = fn( 'float mx_perlin_noise_float( any p )', includes );\r\nexport const mx_perlin_noise_vec2 = fn( 'vec2 mx_perlin_noise_vec2( any p )', includes );\r\nexport const mx_perlin_noise_vec3 = fn( 'vec3 mx_perlin_noise_vec3( any p )', includes );\r\n\r\nexport const mx_cell_noise_float = fn( 'float mx_cell_noise_float( vec3 p )', includes );\r\n\r\nexport const mx_worley_noise_float = fn( 'float mx_worley_noise_float( any p, float jitter, int metric )', includes );\r\nexport const mx_worley_noise_vec2 = fn( 'float mx_worley_noise_vec2( any p, float jitter, int metric )', includes );\r\nexport const mx_worley_noise_vec3 = fn( 'float mx_worley_noise_vec3( any p, float jitter, int metric )', includes );\r\n\r\nexport const mx_fractal_noise_float = fn( 'float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )', includes );\r\nexport const mx_fractal_noise_vec2 = fn( 'float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )', includes );\r\nexport const mx_fractal_noise_vec3 = fn( 'float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )', includes );\r\nexport const mx_fractal_noise_vec4 = fn( 'float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )', includes );\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,wBAAwB;AAC7C,SAASC,EAAE,QAAQ,4BAA4B;;AAE/C;AACA;;AAEA,OAAO,MAAMC,QAAQ,GAAGF,IAAI,CAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAG,CAAC;AAEJ,MAAMG,QAAQ,GAAG,CAAED,QAAQ,CAAE;AAE7B,OAAO,MAAME,qBAAqB,GAAGH,EAAE,CAAE,sCAAsC,EAAEE,QAAS,CAAC;AAC3F,OAAO,MAAME,oBAAoB,GAAGJ,EAAE,CAAE,oCAAoC,EAAEE,QAAS,CAAC;AACxF,OAAO,MAAMG,oBAAoB,GAAGL,EAAE,CAAE,oCAAoC,EAAEE,QAAS,CAAC;AAExF,OAAO,MAAMI,mBAAmB,GAAGN,EAAE,CAAE,qCAAqC,EAAEE,QAAS,CAAC;AAExF,OAAO,MAAMK,qBAAqB,GAAGP,EAAE,CAAE,gEAAgE,EAAEE,QAAS,CAAC;AACrH,OAAO,MAAMM,oBAAoB,GAAGR,EAAE,CAAE,+DAA+D,EAAEE,QAAS,CAAC;AACnH,OAAO,MAAMO,oBAAoB,GAAGT,EAAE,CAAE,+DAA+D,EAAEE,QAAS,CAAC;AAEnH,OAAO,MAAMQ,sBAAsB,GAAGV,EAAE,CAAE,uFAAuF,EAAEE,QAAS,CAAC;AAC7I,OAAO,MAAMS,qBAAqB,GAAGX,EAAE,CAAE,sFAAsF,EAAEE,QAAS,CAAC;AAC3I,OAAO,MAAMU,qBAAqB,GAAGZ,EAAE,CAAE,sFAAsF,EAAEE,QAAS,CAAC;AAC3I,OAAO,MAAMW,qBAAqB,GAAGb,EAAE,CAAE,sFAAsF,EAAEE,QAAS,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}