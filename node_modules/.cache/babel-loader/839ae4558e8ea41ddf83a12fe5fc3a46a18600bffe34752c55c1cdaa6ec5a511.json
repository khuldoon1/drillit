{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement(name, nodeElement) {\n  if (NodeElements.has(name)) throw new Error(`Redefinition of node element ${name}`);\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst shaderNodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get: function (node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return function () {\n          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n          }\n          return nodeElement(nodeObj, ...params);\n        };\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return function () {\n          for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            params[_key2] = arguments[_key2];\n          }\n          return nodeObj.assign(nodeElement(nodeObj, ...params));\n        };\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return nodeObject(new SplitNode(node, prop));\n      } else if (prop === 'width' || prop === 'height') {\n        // accessing property\n\n        return nodeObject(new SplitNode(node, prop === 'width' ? 'x' : 'y'));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(node, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return node[prop];\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return shader(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return function () {\n      for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        params[_key4] = arguments[_key4];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return function () {\n      for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        params[_key5] = arguments[_key5];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass) {\n  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    params[_key6 - 1] = arguments[_key6];\n  }\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc) {\n    super();\n    this._jsFunc = jsFunc;\n  }\n  call(inputs, stack, builder) {\n    inputs = nodeObjects(inputs);\n    return nodeObject(this._jsFunc(inputs, stack, builder));\n  }\n  getNodeType(builder) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);\n  }\n  construct(builder) {\n    builder.addStack();\n    builder.stack.outputNode = nodeObject(this._jsFunc(builder.stack, builder));\n    return builder.removeStack();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch {\n    return undefined;\n  }\n};\nconst ConvertType = function (type) {\n  let cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      params[_key7] = arguments[_key7];\n    }\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\n// utils\n\nexport const getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nexport function ShaderNode(jsFunc) {\n  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);\n}\nexport const nodeObject = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (/* new */ShaderNodeObject(val, altType)\n  );\n};\nexport const nodeObjects = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeObjects(val, altType);\n};\nexport const nodeArray = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeArray(val, altType);\n};\nexport const nodeProxy = function () {\n  for (var _len8 = arguments.length, val = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    val[_key8] = arguments[_key8];\n  }\n  return new ShaderNodeProxy(...val);\n};\nexport const nodeImmutable = function () {\n  for (var _len9 = arguments.length, val = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    val[_key9] = arguments[_key9];\n  }\n  return new ShaderNodeImmutable(...val);\n};\nexport const shader = function () {\n  for (var _len10 = arguments.length, val = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    val[_key10] = arguments[_key10];\n  }\n  return new ShaderNode(...val);\n};\naddNodeClass(ShaderNode);\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport const color = new ConvertType('color');\nexport const float = new ConvertType('float', cacheMaps.float);\nexport const int = new ConvertType('int', cacheMaps.int);\nexport const uint = new ConvertType('uint', cacheMaps.uint);\nexport const bool = new ConvertType('bool', cacheMaps.bool);\nexport const vec2 = new ConvertType('vec2');\nexport const ivec2 = new ConvertType('ivec2');\nexport const uvec2 = new ConvertType('uvec2');\nexport const bvec2 = new ConvertType('bvec2');\nexport const vec3 = new ConvertType('vec3');\nexport const ivec3 = new ConvertType('ivec3');\nexport const uvec3 = new ConvertType('uvec3');\nexport const bvec3 = new ConvertType('bvec3');\nexport const vec4 = new ConvertType('vec4');\nexport const ivec4 = new ConvertType('ivec4');\nexport const uvec4 = new ConvertType('uvec4');\nexport const bvec4 = new ConvertType('bvec4');\nexport const mat3 = new ConvertType('mat3');\nexport const imat3 = new ConvertType('imat3');\nexport const umat3 = new ConvertType('umat3');\nexport const bmat3 = new ConvertType('bmat3');\nexport const mat4 = new ConvertType('mat4');\nexport const imat4 = new ConvertType('imat4');\nexport const umat4 = new ConvertType('umat4');\nexport const bmat4 = new ConvertType('bmat4');\nexport const string = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return nodeObject(new ConstNode(value, 'string'));\n};\nexport const arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddNodeElement('color', color);\naddNodeElement('float', float);\naddNodeElement('int', int);\naddNodeElement('uint', uint);\naddNodeElement('bool', bool);\naddNodeElement('vec2', vec2);\naddNodeElement('ivec2', ivec2);\naddNodeElement('uvec2', uvec2);\naddNodeElement('bvec2', bvec2);\naddNodeElement('vec3', vec3);\naddNodeElement('ivec3', ivec3);\naddNodeElement('uvec3', uvec3);\naddNodeElement('bvec3', bvec3);\naddNodeElement('vec4', vec4);\naddNodeElement('ivec4', ivec4);\naddNodeElement('uvec4', uvec4);\naddNodeElement('bvec4', bvec4);\naddNodeElement('mat3', mat3);\naddNodeElement('imat3', imat3);\naddNodeElement('umat3', umat3);\naddNodeElement('bmat3', bmat3);\naddNodeElement('mat4', mat4);\naddNodeElement('imat4', imat4);\naddNodeElement('umat4', umat4);\naddNodeElement('bmat4', bmat4);\naddNodeElement('string', string);\naddNodeElement('arrayBuffer', arrayBuffer);\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport const element = nodeProxy(ArrayElementNode);\nexport const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nexport const split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddNodeElement('element', element);\naddNodeElement('convert', convert);","map":{"version":3,"names":["Node","addNodeClass","ArrayElementNode","ConvertNode","JoinNode","SplitNode","ConstNode","getValueFromType","getValueType","NodeElements","Map","addNodeElement","name","nodeElement","has","Error","set","shaderNodeHandler","construct","NodeClosure","params","inputs","shift","nodeObjects","get","node","prop","nodeObj","undefined","_len","arguments","length","Array","_key","endsWith","slice","_len2","_key2","assign","test","replace","nodeObject","Number","nodeObjectsCacheMap","WeakMap","ShaderNodeObject","obj","altType","type","Proxy","getConstNode","shader","ShaderNodeObjects","objects","ShaderNodeArray","array","len","i","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","Object","_len3","_key3","nodeArray","_len4","_key4","_len5","_key5","ShaderNodeImmutable","_len6","_key6","ShaderNodeInternal","constructor","jsFunc","_jsFunc","call","stack","builder","getNodeType","outputNode","getNodeProperties","addStack","removeStack","bools","uints","ints","floats","Math","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","value","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","isNode","safeGetNodeType","ConvertType","cacheMap","_len7","_key7","includes","every","param","nodes","getConstNodeType","nodeType","convertTo","ShaderNode","val","nodeProxy","_len8","_key8","nodeImmutable","_len9","_key9","_len10","_key10","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","string","arrayBuffer","element","convert","types","split","channels"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\r\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\r\nimport ConvertNode from '../utils/ConvertNode.js';\r\nimport JoinNode from '../utils/JoinNode.js';\r\nimport SplitNode from '../utils/SplitNode.js';\r\nimport ConstNode from '../core/ConstNode.js';\r\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\r\n\r\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\r\n\r\nexport function addNodeElement( name, nodeElement ) {\r\n\r\n\tif ( NodeElements.has( name ) ) throw new Error( `Redefinition of node element ${ name }` );\r\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\r\n\r\n\tNodeElements.set( name, nodeElement );\r\n\r\n}\r\n\r\nconst shaderNodeHandler = {\r\n\r\n\tconstruct( NodeClosure, params ) {\r\n\r\n\t\tconst inputs = params.shift();\r\n\r\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\r\n\r\n\t},\r\n\r\n\tget: function ( node, prop, nodeObj ) {\r\n\r\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\r\n\r\n\t\t\tif ( NodeElements.has( prop ) ) {\r\n\r\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\r\n\r\n\t\t\t\treturn ( ...params ) => nodeElement( nodeObj, ...params );\r\n\r\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\r\n\r\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\r\n\r\n\t\t\t\treturn ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\r\n\r\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\r\n\r\n\t\t\t\t// accessing properties ( swizzle )\r\n\r\n\t\t\t\tprop = prop\r\n\t\t\t\t\t.replace( /r|s/g, 'x' )\r\n\t\t\t\t\t.replace( /g|t/g, 'y' )\r\n\t\t\t\t\t.replace( /b|p/g, 'z' )\r\n\t\t\t\t\t.replace( /a|q/g, 'w' );\r\n\r\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\r\n\r\n\t\t\t} else if ( prop === 'width' || prop === 'height' ) {\r\n\r\n\t\t\t\t// accessing property\r\n\r\n\t\t\t\treturn nodeObject( new SplitNode( node, prop === 'width' ? 'x' : 'y' ) );\r\n\r\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\r\n\r\n\t\t\t\t// accessing array\r\n\r\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn node[ prop ];\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst nodeObjectsCacheMap = new WeakMap();\r\n\r\nconst ShaderNodeObject = function ( obj, altType = null ) {\r\n\r\n\tconst type = getValueType( obj );\r\n\r\n\tif ( type === 'node' ) {\r\n\r\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\r\n\r\n\t\tif ( nodeObject === undefined ) {\r\n\r\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\r\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\r\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\r\n\r\n\t\t}\r\n\r\n\t\treturn nodeObject;\r\n\r\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\r\n\r\n\t\treturn nodeObject( getConstNode( obj, altType ) );\r\n\r\n\t} else if ( type === 'shader' ) {\r\n\r\n\t\treturn shader( obj );\r\n\r\n\t}\r\n\r\n\treturn obj;\r\n\r\n};\r\n\r\nconst ShaderNodeObjects = function ( objects, altType = null ) {\r\n\r\n\tfor ( const name in objects ) {\r\n\r\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\r\n\r\n\t}\r\n\r\n\treturn objects;\r\n\r\n};\r\n\r\nconst ShaderNodeArray = function ( array, altType = null ) {\r\n\r\n\tconst len = array.length;\r\n\r\n\tfor ( let i = 0; i < len; i ++ ) {\r\n\r\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\r\n\r\n\t}\r\n\r\n\treturn array;\r\n\r\n};\r\n\r\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\r\n\r\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\r\n\r\n\tif ( scope === null ) {\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\r\n\r\n\t\t};\r\n\r\n\t} else if ( factor !== null ) {\r\n\r\n\t\tfactor = nodeObject( factor );\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\r\n\r\n\t\t};\r\n\r\n\t} else {\r\n\r\n\t\treturn ( ...params ) => {\r\n\r\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\r\n\r\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\r\n\r\n};\r\n\r\nclass ShaderNodeInternal extends Node {\r\n\r\n\tconstructor( jsFunc ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis._jsFunc = jsFunc;\r\n\r\n\t}\r\n\r\n\tcall( inputs, stack, builder ) {\r\n\r\n\t\tinputs = nodeObjects( inputs );\r\n\r\n\t\treturn nodeObject( this._jsFunc( inputs, stack, builder ) );\r\n\r\n\t}\r\n\r\n\tgetNodeType( builder ) {\r\n\r\n\t\tconst { outputNode } = builder.getNodeProperties( this );\r\n\r\n\t\treturn outputNode ? outputNode.getNodeType( builder ) : super.getNodeType( builder );\r\n\r\n\t}\r\n\r\n\tconstruct( builder ) {\r\n\r\n\t\tbuilder.addStack();\r\n\r\n\t\tbuilder.stack.outputNode = nodeObject( this._jsFunc( builder.stack, builder ) );\r\n\r\n\t\treturn builder.removeStack();\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst bools = [ false, true ];\r\nconst uints = [ 0, 1, 2, 3 ];\r\nconst ints = [ - 1, - 2 ];\r\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\r\n\r\nconst boolsCacheMap = new Map();\r\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\r\n\r\nconst uintsCacheMap = new Map();\r\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\r\n\r\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\r\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\r\n\r\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\r\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\r\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\r\n\r\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\r\n\r\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\r\n\r\nconst getConstNode = ( value, type ) => {\r\n\r\n\tif ( constNodesCacheMap.has( value ) ) {\r\n\r\n\t\treturn constNodesCacheMap.get( value );\r\n\r\n\t} else if ( value.isNode === true ) {\r\n\r\n\t\treturn value;\r\n\r\n\t} else {\r\n\r\n\t\treturn new ConstNode( value, type );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst safeGetNodeType = ( node ) => {\r\n\r\n\ttry {\r\n\r\n\t\treturn node.getNodeType();\r\n\r\n\t} catch {\r\n\r\n\t\treturn undefined;\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst ConvertType = function ( type, cacheMap = null ) {\r\n\r\n\treturn ( ...params ) => {\r\n\r\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\r\n\r\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\r\n\r\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( params.length === 1 ) {\r\n\r\n\t\t\tconst node = getConstNode( params[ 0 ], type );\r\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\r\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst nodes = params.map( param => getConstNode( param ) );\r\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// exports\r\n\r\n// utils\r\n\r\nexport const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\r\n\r\n// shader node base\r\n\r\nexport function ShaderNode( jsFunc ) {\r\n\r\n\treturn new Proxy( new ShaderNodeInternal( jsFunc ), shaderNodeHandler );\r\n\r\n}\r\n\r\nexport const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\r\nexport const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\r\nexport const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\r\nexport const nodeProxy = ( ...val ) => new ShaderNodeProxy( ...val );\r\nexport const nodeImmutable = ( ...val ) => new ShaderNodeImmutable( ...val );\r\n\r\nexport const shader = ( ...val ) => new ShaderNode( ...val );\r\n\r\naddNodeClass( ShaderNode );\r\n\r\n// types\r\n// @TODO: Maybe export from ConstNode.js?\r\n\r\nexport const color = new ConvertType( 'color' );\r\n\r\nexport const float = new ConvertType( 'float', cacheMaps.float );\r\nexport const int = new ConvertType( 'int', cacheMaps.int );\r\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\r\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\r\n\r\nexport const vec2 = new ConvertType( 'vec2' );\r\nexport const ivec2 = new ConvertType( 'ivec2' );\r\nexport const uvec2 = new ConvertType( 'uvec2' );\r\nexport const bvec2 = new ConvertType( 'bvec2' );\r\n\r\nexport const vec3 = new ConvertType( 'vec3' );\r\nexport const ivec3 = new ConvertType( 'ivec3' );\r\nexport const uvec3 = new ConvertType( 'uvec3' );\r\nexport const bvec3 = new ConvertType( 'bvec3' );\r\n\r\nexport const vec4 = new ConvertType( 'vec4' );\r\nexport const ivec4 = new ConvertType( 'ivec4' );\r\nexport const uvec4 = new ConvertType( 'uvec4' );\r\nexport const bvec4 = new ConvertType( 'bvec4' );\r\n\r\nexport const mat3 = new ConvertType( 'mat3' );\r\nexport const imat3 = new ConvertType( 'imat3' );\r\nexport const umat3 = new ConvertType( 'umat3' );\r\nexport const bmat3 = new ConvertType( 'bmat3' );\r\n\r\nexport const mat4 = new ConvertType( 'mat4' );\r\nexport const imat4 = new ConvertType( 'imat4' );\r\nexport const umat4 = new ConvertType( 'umat4' );\r\nexport const bmat4 = new ConvertType( 'bmat4' );\r\n\r\nexport const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\r\nexport const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\r\n\r\naddNodeElement( 'color', color );\r\naddNodeElement( 'float', float );\r\naddNodeElement( 'int', int );\r\naddNodeElement( 'uint', uint );\r\naddNodeElement( 'bool', bool );\r\naddNodeElement( 'vec2', vec2 );\r\naddNodeElement( 'ivec2', ivec2 );\r\naddNodeElement( 'uvec2', uvec2 );\r\naddNodeElement( 'bvec2', bvec2 );\r\naddNodeElement( 'vec3', vec3 );\r\naddNodeElement( 'ivec3', ivec3 );\r\naddNodeElement( 'uvec3', uvec3 );\r\naddNodeElement( 'bvec3', bvec3 );\r\naddNodeElement( 'vec4', vec4 );\r\naddNodeElement( 'ivec4', ivec4 );\r\naddNodeElement( 'uvec4', uvec4 );\r\naddNodeElement( 'bvec4', bvec4 );\r\naddNodeElement( 'mat3', mat3 );\r\naddNodeElement( 'imat3', imat3 );\r\naddNodeElement( 'umat3', umat3 );\r\naddNodeElement( 'bmat3', bmat3 );\r\naddNodeElement( 'mat4', mat4 );\r\naddNodeElement( 'imat4', imat4 );\r\naddNodeElement( 'umat4', umat4 );\r\naddNodeElement( 'bmat4', bmat4 );\r\naddNodeElement( 'string', string );\r\naddNodeElement( 'arrayBuffer', arrayBuffer );\r\n\r\n// basic nodes\r\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\r\nexport const element = nodeProxy( ArrayElementNode );\r\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\r\nexport const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\r\n\r\naddNodeElement( 'element', element );\r\naddNodeElement( 'convert', convert );\r\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,iBAAiB;AACpD,OAAOC,gBAAgB,MAAM,8BAA8B;AAC3D,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAOC,QAAQ,MAAM,sBAAsB;AAC3C,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,SAASC,gBAAgB,EAAEC,YAAY,QAAQ,sBAAsB;AAErE,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC;;AAEhC,OAAO,SAASC,cAAcA,CAAEC,IAAI,EAAEC,WAAW,EAAG;EAEnD,IAAKJ,YAAY,CAACK,GAAG,CAAEF,IAAK,CAAC,EAAG,MAAM,IAAIG,KAAK,CAAG,gCAAgCH,IAAM,EAAE,CAAC;EAC3F,IAAK,OAAOC,WAAW,KAAK,UAAU,EAAG,MAAM,IAAIE,KAAK,CAAG,gBAAgBH,IAAM,oBAAoB,CAAC;EAEtGH,YAAY,CAACO,GAAG,CAAEJ,IAAI,EAAEC,WAAY,CAAC;AAEtC;AAEA,MAAMI,iBAAiB,GAAG;EAEzBC,SAASA,CAAEC,WAAW,EAAEC,MAAM,EAAG;IAEhC,MAAMC,MAAM,GAAGD,MAAM,CAACE,KAAK,CAAC,CAAC;IAE7B,OAAOH,WAAW,CAAEI,WAAW,CAAEF,MAAO,CAAC,EAAE,GAAGD,MAAO,CAAC;EAEvD,CAAC;EAEDI,GAAG,EAAE,SAAAA,CAAWC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAG;IAErC,IAAK,OAAOD,IAAI,KAAK,QAAQ,IAAID,IAAI,CAAEC,IAAI,CAAE,KAAKE,SAAS,EAAG;MAE7D,IAAKnB,YAAY,CAACK,GAAG,CAAEY,IAAK,CAAC,EAAG;QAE/B,MAAMb,WAAW,GAAGJ,YAAY,CAACe,GAAG,CAAEE,IAAK,CAAC;QAE5C,OAAO;UAAA,SAAAG,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAKX,MAAM,OAAAY,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;YAANb,MAAM,CAAAa,IAAA,IAAAH,SAAA,CAAAG,IAAA;UAAA;UAAA,OAAMpB,WAAW,CAAEc,OAAO,EAAE,GAAGP,MAAO,CAAC;QAAA;MAE1D,CAAC,MAAM,IAAKM,IAAI,CAACQ,QAAQ,CAAE,QAAS,CAAC,IAAIzB,YAAY,CAACK,GAAG,CAAEY,IAAI,CAACS,KAAK,CAAE,CAAC,EAAET,IAAI,CAACK,MAAM,GAAG,QAAQ,CAACA,MAAO,CAAE,CAAC,EAAG;QAE7G,MAAMlB,WAAW,GAAGJ,YAAY,CAACe,GAAG,CAAEE,IAAI,CAACS,KAAK,CAAE,CAAC,EAAET,IAAI,CAACK,MAAM,GAAG,QAAQ,CAACA,MAAO,CAAE,CAAC;QAEtF,OAAO;UAAA,SAAAK,KAAA,GAAAN,SAAA,CAAAC,MAAA,EAAKX,MAAM,OAAAY,KAAA,CAAAI,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;YAANjB,MAAM,CAAAiB,KAAA,IAAAP,SAAA,CAAAO,KAAA;UAAA;UAAA,OAAMV,OAAO,CAACW,MAAM,CAAEzB,WAAW,CAAEc,OAAO,EAAE,GAAGP,MAAO,CAAE,CAAC;QAAA;MAE5E,CAAC,MAAM,IAAK,uBAAuB,CAACmB,IAAI,CAAEb,IAAK,CAAC,KAAK,IAAI,EAAG;QAE3D;;QAEAA,IAAI,GAAGA,IAAI,CACTc,OAAO,CAAE,MAAM,EAAE,GAAI,CAAC,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAI,CAAC,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAI,CAAC,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAI,CAAC;QAExB,OAAOC,UAAU,CAAE,IAAIpC,SAAS,CAAEoB,IAAI,EAAEC,IAAK,CAAE,CAAC;MAEjD,CAAC,MAAM,IAAKA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,QAAQ,EAAG;QAEnD;;QAEA,OAAOe,UAAU,CAAE,IAAIpC,SAAS,CAAEoB,IAAI,EAAEC,IAAI,KAAK,OAAO,GAAG,GAAG,GAAG,GAAI,CAAE,CAAC;MAEzE,CAAC,MAAM,IAAK,OAAO,CAACa,IAAI,CAAEb,IAAK,CAAC,KAAK,IAAI,EAAG;QAE3C;;QAEA,OAAOe,UAAU,CAAE,IAAIvC,gBAAgB,CAAEuB,IAAI,EAAE,IAAInB,SAAS,CAAEoC,MAAM,CAAEhB,IAAK,CAAC,EAAE,MAAO,CAAE,CAAE,CAAC;MAE3F;IAED;IAEA,OAAOD,IAAI,CAAEC,IAAI,CAAE;EAEpB;AAED,CAAC;AAED,MAAMiB,mBAAmB,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEzC,MAAMC,gBAAgB,GAAG,SAAAA,CAAWC,GAAG,EAAmB;EAAA,IAAjBC,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAEtD,MAAMkB,IAAI,GAAGxC,YAAY,CAAEsC,GAAI,CAAC;EAEhC,IAAKE,IAAI,KAAK,MAAM,EAAG;IAEtB,IAAIP,UAAU,GAAGE,mBAAmB,CAACnB,GAAG,CAAEsB,GAAI,CAAC;IAE/C,IAAKL,UAAU,KAAKb,SAAS,EAAG;MAE/Ba,UAAU,GAAG,IAAIQ,KAAK,CAAEH,GAAG,EAAE7B,iBAAkB,CAAC;MAChD0B,mBAAmB,CAAC3B,GAAG,CAAE8B,GAAG,EAAEL,UAAW,CAAC;MAC1CE,mBAAmB,CAAC3B,GAAG,CAAEyB,UAAU,EAAEA,UAAW,CAAC;IAElD;IAEA,OAAOA,UAAU;EAElB,CAAC,MAAM,IAAOM,OAAO,KAAK,IAAI,KAAMC,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,SAAS,CAAE,IAAQA,IAAI,IAAIA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,QAAU,EAAG;IAEtI,OAAOP,UAAU,CAAES,YAAY,CAAEJ,GAAG,EAAEC,OAAQ,CAAE,CAAC;EAElD,CAAC,MAAM,IAAKC,IAAI,KAAK,QAAQ,EAAG;IAE/B,OAAOG,MAAM,CAAEL,GAAI,CAAC;EAErB;EAEA,OAAOA,GAAG;AAEX,CAAC;AAED,MAAMM,iBAAiB,GAAG,SAAAA,CAAWC,OAAO,EAAmB;EAAA,IAAjBN,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAE3D,KAAM,MAAMlB,IAAI,IAAIyC,OAAO,EAAG;IAE7BA,OAAO,CAAEzC,IAAI,CAAE,GAAG6B,UAAU,CAAEY,OAAO,CAAEzC,IAAI,CAAE,EAAEmC,OAAQ,CAAC;EAEzD;EAEA,OAAOM,OAAO;AAEf,CAAC;AAED,MAAMC,eAAe,GAAG,SAAAA,CAAWC,KAAK,EAAmB;EAAA,IAAjBR,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAEvD,MAAM0B,GAAG,GAAGD,KAAK,CAACxB,MAAM;EAExB,KAAM,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAG,EAAG;IAEhCF,KAAK,CAAEE,CAAC,CAAE,GAAGhB,UAAU,CAAEc,KAAK,CAAEE,CAAC,CAAE,EAAEV,OAAQ,CAAC;EAE/C;EAEA,OAAOQ,KAAK;AAEb,CAAC;AAED,MAAMG,eAAe,GAAG,SAAAA,CAAWC,SAAS,EAAiD;EAAA,IAA/CC,KAAK,GAAA9B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAAA,IAAE+B,MAAM,GAAA/B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAAA,IAAEgC,QAAQ,GAAAhC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAEzF,MAAMiC,UAAU,GAAKtC,IAAI,IAAMgB,UAAU,CAAEqB,QAAQ,KAAK,IAAI,GAAGE,MAAM,CAAC1B,MAAM,CAAEb,IAAI,EAAEqC,QAAS,CAAC,GAAGrC,IAAK,CAAC;EAEvG,IAAKmC,KAAK,KAAK,IAAI,EAAG;IAErB,OAAO,YAAiB;MAAA,SAAAK,KAAA,GAAAnC,SAAA,CAAAC,MAAA,EAAZX,MAAM,OAAAY,KAAA,CAAAiC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAN9C,MAAM,CAAA8C,KAAA,IAAApC,SAAA,CAAAoC,KAAA;MAAA;MAEjB,OAAOH,UAAU,CAAE,IAAIJ,SAAS,CAAE,GAAGQ,SAAS,CAAE/C,MAAO,CAAE,CAAE,CAAC;IAE7D,CAAC;EAEF,CAAC,MAAM,IAAKyC,MAAM,KAAK,IAAI,EAAG;IAE7BA,MAAM,GAAGpB,UAAU,CAAEoB,MAAO,CAAC;IAE7B,OAAO,YAAiB;MAAA,SAAAO,KAAA,GAAAtC,SAAA,CAAAC,MAAA,EAAZX,MAAM,OAAAY,KAAA,CAAAoC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAANjD,MAAM,CAAAiD,KAAA,IAAAvC,SAAA,CAAAuC,KAAA;MAAA;MAEjB,OAAON,UAAU,CAAE,IAAIJ,SAAS,CAAEC,KAAK,EAAE,GAAGO,SAAS,CAAE/C,MAAO,CAAC,EAAEyC,MAAO,CAAE,CAAC;IAE5E,CAAC;EAEF,CAAC,MAAM;IAEN,OAAO,YAAiB;MAAA,SAAAS,KAAA,GAAAxC,SAAA,CAAAC,MAAA,EAAZX,MAAM,OAAAY,KAAA,CAAAsC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAANnD,MAAM,CAAAmD,KAAA,IAAAzC,SAAA,CAAAyC,KAAA;MAAA;MAEjB,OAAOR,UAAU,CAAE,IAAIJ,SAAS,CAAEC,KAAK,EAAE,GAAGO,SAAS,CAAE/C,MAAO,CAAE,CAAE,CAAC;IAEpE,CAAC;EAEF;AAED,CAAC;AAED,MAAMoD,mBAAmB,GAAG,SAAAA,CAAWb,SAAS,EAAc;EAAA,SAAAc,KAAA,GAAA3C,SAAA,CAAAC,MAAA,EAATX,MAAM,OAAAY,KAAA,CAAAyC,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAANtD,MAAM,CAAAsD,KAAA,QAAA5C,SAAA,CAAA4C,KAAA;EAAA;EAE1D,OAAOjC,UAAU,CAAE,IAAIkB,SAAS,CAAE,GAAGQ,SAAS,CAAE/C,MAAO,CAAE,CAAE,CAAC;AAE7D,CAAC;AAED,MAAMuD,kBAAkB,SAAS3E,IAAI,CAAC;EAErC4E,WAAWA,CAAEC,MAAM,EAAG;IAErB,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,OAAO,GAAGD,MAAM;EAEtB;EAEAE,IAAIA,CAAE1D,MAAM,EAAE2D,KAAK,EAAEC,OAAO,EAAG;IAE9B5D,MAAM,GAAGE,WAAW,CAAEF,MAAO,CAAC;IAE9B,OAAOoB,UAAU,CAAE,IAAI,CAACqC,OAAO,CAAEzD,MAAM,EAAE2D,KAAK,EAAEC,OAAQ,CAAE,CAAC;EAE5D;EAEAC,WAAWA,CAAED,OAAO,EAAG;IAEtB,MAAM;MAAEE;IAAW,CAAC,GAAGF,OAAO,CAACG,iBAAiB,CAAE,IAAK,CAAC;IAExD,OAAOD,UAAU,GAAGA,UAAU,CAACD,WAAW,CAAED,OAAQ,CAAC,GAAG,KAAK,CAACC,WAAW,CAAED,OAAQ,CAAC;EAErF;EAEA/D,SAASA,CAAE+D,OAAO,EAAG;IAEpBA,OAAO,CAACI,QAAQ,CAAC,CAAC;IAElBJ,OAAO,CAACD,KAAK,CAACG,UAAU,GAAG1C,UAAU,CAAE,IAAI,CAACqC,OAAO,CAAEG,OAAO,CAACD,KAAK,EAAEC,OAAQ,CAAE,CAAC;IAE/E,OAAOA,OAAO,CAACK,WAAW,CAAC,CAAC;EAE7B;AAED;AAEA,MAAMC,KAAK,GAAG,CAAE,KAAK,EAAE,IAAI,CAAE;AAC7B,MAAMC,KAAK,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;AAC5B,MAAMC,IAAI,GAAG,CAAE,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE;AACzB,MAAMC,MAAM,GAAG,CAAE,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,GAAG,EAAEC,IAAI,CAACC,EAAE,EAAED,IAAI,CAACC,EAAE,GAAG,CAAC,EAAE,CAAC,GAAGD,IAAI,CAACC,EAAE,EAAE,CAAC,GAAGD,IAAI,CAACC,EAAE,EAAE,CAAC,IAAKD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAE,EAAED,IAAI,CAACC,EAAE,GAAG,CAAC,CAAE;AAE/H,MAAMC,aAAa,GAAG,IAAInF,GAAG,CAAC,CAAC;AAC/B,KAAM,MAAMoF,IAAI,IAAIP,KAAK,EAAGM,aAAa,CAAC7E,GAAG,CAAE8E,IAAI,EAAE,IAAIxF,SAAS,CAAEwF,IAAK,CAAE,CAAC;AAE5E,MAAMC,aAAa,GAAG,IAAIrF,GAAG,CAAC,CAAC;AAC/B,KAAM,MAAMsF,IAAI,IAAIR,KAAK,EAAGO,aAAa,CAAC/E,GAAG,CAAEgF,IAAI,EAAE,IAAI1F,SAAS,CAAE0F,IAAI,EAAE,MAAO,CAAE,CAAC;AAEpF,MAAMC,YAAY,GAAG,IAAIvF,GAAG,CAAE,CAAE,GAAGqF,aAAa,CAAE,CAACG,GAAG,CAAEC,EAAE,IAAI,IAAI7F,SAAS,CAAE6F,EAAE,CAACC,KAAK,EAAE,KAAM,CAAE,CAAE,CAAC;AAClG,KAAM,MAAMC,GAAG,IAAIZ,IAAI,EAAGQ,YAAY,CAACjF,GAAG,CAAEqF,GAAG,EAAE,IAAI/F,SAAS,CAAE+F,GAAG,EAAE,KAAM,CAAE,CAAC;AAE9E,MAAMC,cAAc,GAAG,IAAI5F,GAAG,CAAE,CAAE,GAAGuF,YAAY,CAAE,CAACC,GAAG,CAAEC,EAAE,IAAI,IAAI7F,SAAS,CAAE6F,EAAE,CAACC,KAAM,CAAE,CAAE,CAAC;AAC5F,KAAM,MAAMG,KAAK,IAAIb,MAAM,EAAGY,cAAc,CAACtF,GAAG,CAAEuF,KAAK,EAAE,IAAIjG,SAAS,CAAEiG,KAAM,CAAE,CAAC;AACjF,KAAM,MAAMA,KAAK,IAAIb,MAAM,EAAGY,cAAc,CAACtF,GAAG,CAAE,CAAEuF,KAAK,EAAE,IAAIjG,SAAS,CAAE,CAAEiG,KAAM,CAAE,CAAC;AAErF,MAAMC,SAAS,GAAG;EAAEV,IAAI,EAAED,aAAa;EAAEG,IAAI,EAAED,aAAa;EAAEN,IAAI,EAAEQ,YAAY;EAAEM,KAAK,EAAED;AAAe,CAAC;AAEzG,MAAMG,kBAAkB,GAAG,IAAI/F,GAAG,CAAE,CAAE,GAAGmF,aAAa,EAAE,GAAGS,cAAc,CAAG,CAAC;AAE7E,MAAMpD,YAAY,GAAGA,CAAEkD,KAAK,EAAEpD,IAAI,KAAM;EAEvC,IAAKyD,kBAAkB,CAAC3F,GAAG,CAAEsF,KAAM,CAAC,EAAG;IAEtC,OAAOK,kBAAkB,CAACjF,GAAG,CAAE4E,KAAM,CAAC;EAEvC,CAAC,MAAM,IAAKA,KAAK,CAACM,MAAM,KAAK,IAAI,EAAG;IAEnC,OAAON,KAAK;EAEb,CAAC,MAAM;IAEN,OAAO,IAAI9F,SAAS,CAAE8F,KAAK,EAAEpD,IAAK,CAAC;EAEpC;AAED,CAAC;AAED,MAAM2D,eAAe,GAAKlF,IAAI,IAAM;EAEnC,IAAI;IAEH,OAAOA,IAAI,CAACyD,WAAW,CAAC,CAAC;EAE1B,CAAC,CAAC,MAAM;IAEP,OAAOtD,SAAS;EAEjB;AAED,CAAC;AAED,MAAMgF,WAAW,GAAG,SAAAA,CAAW5D,IAAI,EAAoB;EAAA,IAAlB6D,QAAQ,GAAA/E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAEnD,OAAO,YAAiB;IAAA,SAAAgF,KAAA,GAAAhF,SAAA,CAAAC,MAAA,EAAZX,MAAM,OAAAY,KAAA,CAAA8E,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAN3F,MAAM,CAAA2F,KAAA,IAAAjF,SAAA,CAAAiF,KAAA;IAAA;IAEjB,IAAK3F,MAAM,CAACW,MAAM,KAAK,CAAC,IAAM,CAAE,CAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAE,CAACiF,QAAQ,CAAEhE,IAAK,CAAC,IAAI5B,MAAM,CAAC6F,KAAK,CAAEC,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAS,CAAG,EAAG;MAE7I9F,MAAM,GAAG,CAAEb,gBAAgB,CAAEyC,IAAI,EAAE,GAAG5B,MAAO,CAAC,CAAE;IAEjD;IAEA,IAAKA,MAAM,CAACW,MAAM,KAAK,CAAC,IAAI8E,QAAQ,KAAK,IAAI,IAAIA,QAAQ,CAAC/F,GAAG,CAAEM,MAAM,CAAE,CAAC,CAAG,CAAC,EAAG;MAE9E,OAAOqB,UAAU,CAAEoE,QAAQ,CAACrF,GAAG,CAAEJ,MAAM,CAAE,CAAC,CAAG,CAAE,CAAC;IAEjD;IAEA,IAAKA,MAAM,CAACW,MAAM,KAAK,CAAC,EAAG;MAE1B,MAAMN,IAAI,GAAGyB,YAAY,CAAE9B,MAAM,CAAE,CAAC,CAAE,EAAE4B,IAAK,CAAC;MAC9C,IAAK2D,eAAe,CAAElF,IAAK,CAAC,KAAKuB,IAAI,EAAG,OAAOP,UAAU,CAAEhB,IAAK,CAAC;MACjE,OAAOgB,UAAU,CAAE,IAAItC,WAAW,CAAEsB,IAAI,EAAEuB,IAAK,CAAE,CAAC;IAEnD;IAEA,MAAMmE,KAAK,GAAG/F,MAAM,CAAC8E,GAAG,CAAEgB,KAAK,IAAIhE,YAAY,CAAEgE,KAAM,CAAE,CAAC;IAC1D,OAAOzE,UAAU,CAAE,IAAIrC,QAAQ,CAAE+G,KAAK,EAAEnE,IAAK,CAAE,CAAC;EAEjD,CAAC;AAEF,CAAC;;AAED;;AAEA;;AAEA,OAAO,MAAMoE,gBAAgB,GAAKhB,KAAK,IAAQA,KAAK,KAAKxE,SAAS,IAAIwE,KAAK,KAAK,IAAI,GAAOA,KAAK,CAACiB,QAAQ,IAAIjB,KAAK,CAACkB,SAAS,KAAM,OAAOlB,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAG,IAAI,CAAE,GAAK,IAAI;;AAErL;;AAEA,OAAO,SAASmB,UAAUA,CAAE1C,MAAM,EAAG;EAEpC,OAAO,IAAI5B,KAAK,CAAE,IAAI0B,kBAAkB,CAAEE,MAAO,CAAC,EAAE5D,iBAAkB,CAAC;AAExE;AAEA,OAAO,MAAMwB,UAAU,GAAG,SAAAA,CAAE+E,GAAG;EAAA,IAAEzE,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAAA,OAAM,UAAUe,gBAAgB,CAAE2E,GAAG,EAAEzE,OAAQ;EAAC;AAAA;AAC/F,OAAO,MAAMxB,WAAW,GAAG,SAAAA,CAAEiG,GAAG;EAAA,IAAEzE,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAAA,OAAM,IAAIsB,iBAAiB,CAAEoE,GAAG,EAAEzE,OAAQ,CAAC;AAAA;AAC3F,OAAO,MAAMoB,SAAS,GAAG,SAAAA,CAAEqD,GAAG;EAAA,IAAEzE,OAAO,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,IAAI;EAAA,OAAM,IAAIwB,eAAe,CAAEkE,GAAG,EAAEzE,OAAQ,CAAC;AAAA;AACvF,OAAO,MAAM0E,SAAS,GAAG,SAAAA,CAAA;EAAA,SAAAC,KAAA,GAAA5F,SAAA,CAAAC,MAAA,EAAKyF,GAAG,OAAAxF,KAAA,CAAA0F,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAHH,GAAG,CAAAG,KAAA,IAAA7F,SAAA,CAAA6F,KAAA;EAAA;EAAA,OAAM,IAAIjE,eAAe,CAAE,GAAG8D,GAAI,CAAC;AAAA;AACpE,OAAO,MAAMI,aAAa,GAAG,SAAAA,CAAA;EAAA,SAAAC,KAAA,GAAA/F,SAAA,CAAAC,MAAA,EAAKyF,GAAG,OAAAxF,KAAA,CAAA6F,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAHN,GAAG,CAAAM,KAAA,IAAAhG,SAAA,CAAAgG,KAAA;EAAA;EAAA,OAAM,IAAItD,mBAAmB,CAAE,GAAGgD,GAAI,CAAC;AAAA;AAE5E,OAAO,MAAMrE,MAAM,GAAG,SAAAA,CAAA;EAAA,SAAA4E,MAAA,GAAAjG,SAAA,CAAAC,MAAA,EAAKyF,GAAG,OAAAxF,KAAA,CAAA+F,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;IAAHR,GAAG,CAAAQ,MAAA,IAAAlG,SAAA,CAAAkG,MAAA;EAAA;EAAA,OAAM,IAAIT,UAAU,CAAE,GAAGC,GAAI,CAAC;AAAA;AAE5DvH,YAAY,CAAEsH,UAAW,CAAC;;AAE1B;AACA;;AAEA,OAAO,MAAMU,KAAK,GAAG,IAAIrB,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAML,KAAK,GAAG,IAAIK,WAAW,CAAE,OAAO,EAAEJ,SAAS,CAACD,KAAM,CAAC;AAChE,OAAO,MAAMF,GAAG,GAAG,IAAIO,WAAW,CAAE,KAAK,EAAEJ,SAAS,CAACH,GAAI,CAAC;AAC1D,OAAO,MAAML,IAAI,GAAG,IAAIY,WAAW,CAAE,MAAM,EAAEJ,SAAS,CAACR,IAAK,CAAC;AAC7D,OAAO,MAAMF,IAAI,GAAG,IAAIc,WAAW,CAAE,MAAM,EAAEJ,SAAS,CAACV,IAAK,CAAC;AAE7D,OAAO,MAAMoC,IAAI,GAAG,IAAItB,WAAW,CAAE,MAAO,CAAC;AAC7C,OAAO,MAAMuB,KAAK,GAAG,IAAIvB,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMwB,KAAK,GAAG,IAAIxB,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMyB,KAAK,GAAG,IAAIzB,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAM0B,IAAI,GAAG,IAAI1B,WAAW,CAAE,MAAO,CAAC;AAC7C,OAAO,MAAM2B,KAAK,GAAG,IAAI3B,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAM4B,KAAK,GAAG,IAAI5B,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAM6B,KAAK,GAAG,IAAI7B,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAM8B,IAAI,GAAG,IAAI9B,WAAW,CAAE,MAAO,CAAC;AAC7C,OAAO,MAAM+B,KAAK,GAAG,IAAI/B,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMgC,KAAK,GAAG,IAAIhC,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMiC,KAAK,GAAG,IAAIjC,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAMkC,IAAI,GAAG,IAAIlC,WAAW,CAAE,MAAO,CAAC;AAC7C,OAAO,MAAMmC,KAAK,GAAG,IAAInC,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMoC,KAAK,GAAG,IAAIpC,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMqC,KAAK,GAAG,IAAIrC,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAMsC,IAAI,GAAG,IAAItC,WAAW,CAAE,MAAO,CAAC;AAC7C,OAAO,MAAMuC,KAAK,GAAG,IAAIvC,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMwC,KAAK,GAAG,IAAIxC,WAAW,CAAE,OAAQ,CAAC;AAC/C,OAAO,MAAMyC,KAAK,GAAG,IAAIzC,WAAW,CAAE,OAAQ,CAAC;AAE/C,OAAO,MAAM0C,MAAM,GAAG,SAAAA,CAAA;EAAA,IAAElD,KAAK,GAAAtE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,EAAE;EAAA,OAAMW,UAAU,CAAE,IAAInC,SAAS,CAAE8F,KAAK,EAAE,QAAS,CAAE,CAAC;AAAA;AACtF,OAAO,MAAMmD,WAAW,GAAKnD,KAAK,IAAM3D,UAAU,CAAE,IAAInC,SAAS,CAAE8F,KAAK,EAAE,aAAc,CAAE,CAAC;AAE3FzF,cAAc,CAAE,OAAO,EAAEsH,KAAM,CAAC;AAChCtH,cAAc,CAAE,OAAO,EAAE4F,KAAM,CAAC;AAChC5F,cAAc,CAAE,KAAK,EAAE0F,GAAI,CAAC;AAC5B1F,cAAc,CAAE,MAAM,EAAEqF,IAAK,CAAC;AAC9BrF,cAAc,CAAE,MAAM,EAAEmF,IAAK,CAAC;AAC9BnF,cAAc,CAAE,MAAM,EAAEuH,IAAK,CAAC;AAC9BvH,cAAc,CAAE,OAAO,EAAEwH,KAAM,CAAC;AAChCxH,cAAc,CAAE,OAAO,EAAEyH,KAAM,CAAC;AAChCzH,cAAc,CAAE,OAAO,EAAE0H,KAAM,CAAC;AAChC1H,cAAc,CAAE,MAAM,EAAE2H,IAAK,CAAC;AAC9B3H,cAAc,CAAE,OAAO,EAAE4H,KAAM,CAAC;AAChC5H,cAAc,CAAE,OAAO,EAAE6H,KAAM,CAAC;AAChC7H,cAAc,CAAE,OAAO,EAAE8H,KAAM,CAAC;AAChC9H,cAAc,CAAE,MAAM,EAAE+H,IAAK,CAAC;AAC9B/H,cAAc,CAAE,OAAO,EAAEgI,KAAM,CAAC;AAChChI,cAAc,CAAE,OAAO,EAAEiI,KAAM,CAAC;AAChCjI,cAAc,CAAE,OAAO,EAAEkI,KAAM,CAAC;AAChClI,cAAc,CAAE,MAAM,EAAEmI,IAAK,CAAC;AAC9BnI,cAAc,CAAE,OAAO,EAAEoI,KAAM,CAAC;AAChCpI,cAAc,CAAE,OAAO,EAAEqI,KAAM,CAAC;AAChCrI,cAAc,CAAE,OAAO,EAAEsI,KAAM,CAAC;AAChCtI,cAAc,CAAE,MAAM,EAAEuI,IAAK,CAAC;AAC9BvI,cAAc,CAAE,OAAO,EAAEwI,KAAM,CAAC;AAChCxI,cAAc,CAAE,OAAO,EAAEyI,KAAM,CAAC;AAChCzI,cAAc,CAAE,OAAO,EAAE0I,KAAM,CAAC;AAChC1I,cAAc,CAAE,QAAQ,EAAE2I,MAAO,CAAC;AAClC3I,cAAc,CAAE,aAAa,EAAE4I,WAAY,CAAC;;AAE5C;AACA;AACA,OAAO,MAAMC,OAAO,GAAG/B,SAAS,CAAEvH,gBAAiB,CAAC;AACpD,OAAO,MAAMuJ,OAAO,GAAGA,CAAEhI,IAAI,EAAEiI,KAAK,KAAMjH,UAAU,CAAE,IAAItC,WAAW,CAAEsC,UAAU,CAAEhB,IAAK,CAAC,EAAEiI,KAAM,CAAE,CAAC;AACpG,OAAO,MAAMC,KAAK,GAAGA,CAAElI,IAAI,EAAEmI,QAAQ,KAAMnH,UAAU,CAAE,IAAIpC,SAAS,CAAEoC,UAAU,CAAEhB,IAAK,CAAC,EAAEmI,QAAS,CAAE,CAAC;AAEtGjJ,cAAc,CAAE,SAAS,EAAE6I,OAAQ,CAAC;AACpC7I,cAAc,CAAE,SAAS,EAAE8I,OAAQ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}