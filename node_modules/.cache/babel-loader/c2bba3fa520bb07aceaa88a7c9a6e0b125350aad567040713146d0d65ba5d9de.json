{"ast":null,"code":"import DataMap from './DataMap.js';\nimport { Color, Mesh, BoxGeometry, BackSide } from 'three';\nimport { context, positionWorldDirection, MeshBasicNodeMaterial } from '../../nodes/Nodes.js';\nlet _clearAlpha;\nconst _clearColor = new Color();\nclass Background extends DataMap {\n  constructor(renderer, nodes) {\n    super();\n    this.renderer = renderer;\n    this.nodes = nodes;\n    this.boxMesh = null;\n    this.boxMeshNode = null;\n  }\n  update(scene, renderList, renderContext) {\n    const renderer = this.renderer;\n    const background = scene.isScene === true ? this.nodes.getBackgroundNode(scene) || scene.background : null;\n    let forceClear = false;\n    if (background === null) {\n      // no background settings, use clear color configuration from the renderer\n\n      _clearColor.copy(renderer._clearColor);\n      _clearAlpha = renderer._clearAlpha;\n    } else if (background.isColor === true) {\n      // background is an opaque color\n\n      _clearColor.copy(background);\n      _clearAlpha = 1;\n      forceClear = true;\n    } else if (background.isNode === true) {\n      const sceneData = this.get(scene);\n      const backgroundNode = background;\n      _clearColor.copy(renderer._clearColor);\n      _clearAlpha = renderer._clearAlpha;\n      let boxMesh = this.boxMesh;\n      if (boxMesh === null) {\n        this.boxMeshNode = context(backgroundNode, {\n          // @TODO: Add Texture2D support using node context\n          getUVNode: () => positionWorldDirection\n        });\n        const nodeMaterial = new MeshBasicNodeMaterial();\n        nodeMaterial.colorNode = this.boxMeshNode;\n        nodeMaterial.side = BackSide;\n        nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n        nodeMaterial.fog = false;\n        this.boxMesh = boxMesh = new Mesh(new BoxGeometry(1, 1, 1), nodeMaterial);\n        boxMesh.frustumCulled = false;\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          const scale = camera.far;\n          this.matrixWorld.makeScale(scale, scale, scale).copyPosition(camera.matrixWorld);\n        };\n      }\n      const backgroundCacheKey = backgroundNode.getCacheKey();\n      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        this.boxMeshNode.node = backgroundNode;\n        boxMesh.material.needsUpdate = true;\n        sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else {\n      console.error('THREE.Renderer: Unsupported background configuration.', background);\n    }\n\n    //\n\n    if (renderer.autoClear === true || forceClear === true) {\n      _clearColor.multiplyScalar(_clearAlpha);\n      const clearColorValue = renderContext.clearColorValue;\n      clearColorValue.r = _clearColor.r;\n      clearColorValue.g = _clearColor.g;\n      clearColorValue.b = _clearColor.b;\n      clearColorValue.a = _clearAlpha;\n      renderContext.depthClearValue = renderer._clearDepth;\n      renderContext.stencilClearValue = renderer._clearStencil;\n      renderContext.clearColor = renderer.autoClearColor === true;\n      renderContext.clearDepth = renderer.autoClearDepth === true;\n      renderContext.clearStencil = renderer.autoClearStencil === true;\n    } else {\n      renderContext.clearColor = false;\n      renderContext.clearDepth = false;\n      renderContext.clearStencil = false;\n    }\n  }\n}\nexport default Background;","map":{"version":3,"names":["DataMap","Color","Mesh","BoxGeometry","BackSide","context","positionWorldDirection","MeshBasicNodeMaterial","_clearAlpha","_clearColor","Background","constructor","renderer","nodes","boxMesh","boxMeshNode","update","scene","renderList","renderContext","background","isScene","getBackgroundNode","forceClear","copy","isColor","isNode","sceneData","get","backgroundNode","getUVNode","nodeMaterial","colorNode","side","depthTest","depthWrite","fog","frustumCulled","onBeforeRender","camera","scale","far","matrixWorld","makeScale","copyPosition","backgroundCacheKey","getCacheKey","node","material","needsUpdate","unshift","geometry","console","error","autoClear","multiplyScalar","clearColorValue","r","g","b","a","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","clearColor","autoClearColor","clearDepth","autoClearDepth","clearStencil","autoClearStencil"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/common/Background.js"],"sourcesContent":["import DataMap from './DataMap.js';\r\nimport { Color, Mesh, BoxGeometry, BackSide } from 'three';\r\nimport { context, positionWorldDirection, MeshBasicNodeMaterial } from '../../nodes/Nodes.js';\r\n\r\nlet _clearAlpha;\r\nconst _clearColor = new Color();\r\n\r\nclass Background extends DataMap {\r\n\r\n\tconstructor( renderer, nodes ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.nodes = nodes;\r\n\r\n\t\tthis.boxMesh = null;\r\n\t\tthis.boxMeshNode = null;\r\n\r\n\t}\r\n\r\n\tupdate( scene, renderList, renderContext ) {\r\n\r\n\t\tconst renderer = this.renderer;\r\n\t\tconst background = ( scene.isScene === true ) ? this.nodes.getBackgroundNode( scene ) || scene.background : null;\r\n\r\n\t\tlet forceClear = false;\r\n\r\n\t\tif ( background === null ) {\r\n\r\n\t\t\t// no background settings, use clear color configuration from the renderer\r\n\r\n\t\t\t_clearColor.copy( renderer._clearColor );\r\n\t\t\t_clearAlpha = renderer._clearAlpha;\r\n\r\n\t\t} else if ( background.isColor === true ) {\r\n\r\n\t\t\t// background is an opaque color\r\n\r\n\t\t\t_clearColor.copy( background );\r\n\t\t\t_clearAlpha = 1;\r\n\t\t\tforceClear = true;\r\n\r\n\t\t} else if ( background.isNode === true ) {\r\n\r\n\t\t\tconst sceneData = this.get( scene );\r\n\t\t\tconst backgroundNode = background;\r\n\r\n\t\t\t_clearColor.copy( renderer._clearColor );\r\n\t\t\t_clearAlpha = renderer._clearAlpha;\r\n\r\n\t\t\tlet boxMesh = this.boxMesh;\r\n\r\n\t\t\tif ( boxMesh === null ) {\r\n\r\n\t\t\t\tthis.boxMeshNode = context( backgroundNode, {\r\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\r\n\t\t\t\t\tgetUVNode: () => positionWorldDirection\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tconst nodeMaterial = new MeshBasicNodeMaterial();\r\n\t\t\t\tnodeMaterial.colorNode = this.boxMeshNode;\r\n\t\t\t\tnodeMaterial.side = BackSide;\r\n\t\t\t\tnodeMaterial.depthTest = false;\r\n\t\t\t\tnodeMaterial.depthWrite = false;\r\n\t\t\t\tnodeMaterial.fog = false;\r\n\r\n\t\t\t\tthis.boxMesh = boxMesh = new Mesh( new BoxGeometry( 1, 1, 1 ), nodeMaterial );\r\n\t\t\t\tboxMesh.frustumCulled = false;\r\n\r\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\t\t\tconst scale = camera.far;\r\n\r\n\t\t\t\t\tthis.matrixWorld.makeScale( scale, scale, scale ).copyPosition( camera.matrixWorld );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\r\n\r\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\r\n\r\n\t\t\t\tthis.boxMeshNode.node = backgroundNode;\r\n\r\n\t\t\t\tboxMesh.material.needsUpdate = true;\r\n\r\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\r\n\r\n\t\t\t}\r\n\r\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\r\n\r\n\t\t\t_clearColor.multiplyScalar( _clearAlpha );\r\n\r\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\r\n\r\n\t\t\tclearColorValue.r = _clearColor.r;\r\n\t\t\tclearColorValue.g = _clearColor.g;\r\n\t\t\tclearColorValue.b = _clearColor.b;\r\n\t\t\tclearColorValue.a = _clearAlpha;\r\n\r\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\r\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\r\n\r\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\r\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\r\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderContext.clearColor = false;\r\n\t\t\trenderContext.clearDepth = false;\r\n\t\t\trenderContext.clearStencil = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default Background;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}