{"ast":null,"code":"import NodeFunction from '../../../nodes/core/NodeFunction.js';\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+)?/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\nconst wgslTypeLib = {\n  f32: 'float'\n};\nconst parse = source => {\n  source = source.trim();\n  const declaration = source.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 4) {\n    // tokenizer\n\n    const inputsCode = declaration[2];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      // default\n\n      const name = propsMatches[i++][0];\n      let type = propsMatches[i++][0];\n      type = wgslTypeLib[type] || type;\n\n      // precision\n\n      if (i < propsMatches.length && /^[fui]\\d{2}$/.test(propsMatches[i][0]) === true) i++;\n\n      // add input\n\n      inputs.push(new NodeFunctionInput(type, name));\n    }\n\n    //\n\n    const blockCode = source.substring(declaration[0].length);\n    const name = declaration[1] !== undefined ? declaration[1] : '';\n    const type = declaration[3] || 'void';\n    return {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a WGSL code.');\n  }\n};\nclass WGSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode\n    } = parse(source);\n    super(type, inputs, name);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n  }\n  getCode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;\n    const type = this.type !== 'void' ? '-> ' + this.type : '';\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${type}` + this.blockCode;\n  }\n}\nexport default WGSLNodeFunction;","map":{"version":3,"names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","wgslTypeLib","f32","parse","source","trim","declaration","match","length","inputsCode","propsMatches","nameMatch","exec","push","inputs","i","name","type","test","blockCode","substring","undefined","Error","WGSLNodeFunction","constructor","getCode","arguments"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../../../nodes/core/NodeFunction.js';\r\nimport NodeFunctionInput from '../../../nodes/core/NodeFunctionInput.js';\r\n\r\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+)?/i;\r\nconst propertiesRegexp = /[a-z_0-9]+/ig;\r\n\r\nconst wgslTypeLib = {\r\n\tf32: 'float'\r\n};\r\n\r\nconst parse = ( source ) => {\r\n\r\n\tsource = source.trim();\r\n\r\n\tconst declaration = source.match( declarationRegexp );\r\n\r\n\tif ( declaration !== null && declaration.length === 4 ) {\r\n\r\n\t\t// tokenizer\r\n\r\n\t\tconst inputsCode = declaration[ 2 ];\r\n\t\tconst propsMatches = [];\r\n\r\n\t\tlet nameMatch = null;\r\n\r\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\r\n\r\n\t\t\tpropsMatches.push( nameMatch );\r\n\r\n\t\t}\r\n\r\n\t\t// parser\r\n\r\n\t\tconst inputs = [];\r\n\r\n\t\tlet i = 0;\r\n\r\n\t\twhile ( i < propsMatches.length ) {\r\n\r\n\t\t\t// default\r\n\r\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\r\n\t\t\tlet type = propsMatches[ i ++ ][ 0 ];\r\n\r\n\t\t\ttype = wgslTypeLib[ type ] || type;\r\n\r\n\t\t\t// precision\r\n\r\n\t\t\tif ( i < propsMatches.length && /^[fui]\\d{2}$/.test( propsMatches[ i ][ 0 ] ) === true )\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t// add input\r\n\r\n\t\t\tinputs.push( new NodeFunctionInput( type, name ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\r\n\r\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\r\n\t\tconst type = declaration[ 3 ] || 'void';\r\n\r\n\t\treturn {\r\n\t\t\ttype,\r\n\t\t\tinputs,\r\n\t\t\tname,\r\n\t\t\tinputsCode,\r\n\t\t\tblockCode\r\n\t\t};\r\n\r\n\t} else {\r\n\r\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nclass WGSLNodeFunction extends NodeFunction {\r\n\r\n\tconstructor( source ) {\r\n\r\n\t\tconst { type, inputs, name, inputsCode, blockCode } = parse( source );\r\n\r\n\t\tsuper( type, inputs, name );\r\n\r\n\t\tthis.inputsCode = inputsCode;\r\n\t\tthis.blockCode = blockCode;\r\n\r\n\t}\r\n\r\n\tgetCode( name = this.name ) {\r\n\r\n\t\tconst type = this.type !== 'void' ? '-> ' + this.type : '';\r\n\r\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ type }` + this.blockCode;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WGSLNodeFunction;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}