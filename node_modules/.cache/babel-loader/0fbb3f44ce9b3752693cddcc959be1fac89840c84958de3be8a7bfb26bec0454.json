{"ast":null,"code":"import { GPUTextureAspect, GPUTextureViewDimension } from './WebGPUConstants.js';\nclass WebGPUBindingUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createBindings(bindings, pipeline) {\n    const backend = this.backend;\n    const bindingsData = backend.get(bindings);\n\n    // setup (static) binding layout and (dynamic) binding group\n\n    const pipelineGPU = backend.get(pipeline).pipeline;\n    const bindLayoutGPU = pipelineGPU.getBindGroupLayout(0);\n    const bindGroupGPU = this.createBindGroup(bindings, bindLayoutGPU);\n    bindingsData.layout = bindLayoutGPU;\n    bindingsData.group = bindGroupGPU;\n    bindingsData.bindings = bindings;\n  }\n  updateBinding(binding) {\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = binding.buffer;\n    const bufferGPU = backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);\n  }\n  createBindGroup(bindings, layoutGPU) {\n    const backend = this.backend;\n    const device = backend.device;\n    let bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of bindings) {\n      if (binding.isUniformBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const byteLength = binding.byteLength;\n          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const bufferGPU = device.createBuffer({\n            label: 'bindingBuffer',\n            size: byteLength,\n            usage: usage\n          });\n          bindingData.buffer = bufferGPU;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isStorageBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const attribute = binding.attribute;\n          //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n          //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n          bindingData.buffer = backend.get(attribute).buffer;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isSampler) {\n        const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: textureGPU.sampler\n        });\n      } else if (binding.isSampledTexture) {\n        const textureData = backend.get(binding.texture);\n        let dimensionViewGPU;\n        if (binding.isSampledCubeTexture) {\n          dimensionViewGPU = GPUTextureViewDimension.Cube;\n        } else {\n          dimensionViewGPU = GPUTextureViewDimension.TwoD;\n        }\n        let resourceGPU;\n        if (textureData.externalTexture !== undefined) {\n          resourceGPU = device.importExternalTexture({\n            source: textureData.externalTexture\n          });\n        } else {\n          const aspectGPU = GPUTextureAspect.All;\n          resourceGPU = textureData.texture.createView({\n            aspect: aspectGPU,\n            dimension: dimensionViewGPU\n          });\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: resourceGPU\n        });\n      }\n      bindingPoint++;\n    }\n    return device.createBindGroup({\n      layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n}\nexport default WebGPUBindingUtils;","map":{"version":3,"names":["GPUTextureAspect","GPUTextureViewDimension","WebGPUBindingUtils","constructor","backend","createBindings","bindings","pipeline","bindingsData","get","pipelineGPU","bindLayoutGPU","getBindGroupLayout","bindGroupGPU","createBindGroup","layout","group","updateBinding","binding","device","buffer","bufferGPU","queue","writeBuffer","layoutGPU","bindingPoint","entriesGPU","isUniformBuffer","bindingData","undefined","byteLength","usage","GPUBufferUsage","UNIFORM","COPY_DST","createBuffer","label","size","push","resource","isStorageBuffer","attribute","isSampler","textureGPU","texture","sampler","isSampledTexture","textureData","dimensionViewGPU","isSampledCubeTexture","Cube","TwoD","resourceGPU","externalTexture","importExternalTexture","source","aspectGPU","All","createView","aspect","dimension","entries"],"sources":["C:/Users/LENOVO/Desktop/reactjsProject/drillit/node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUBindingUtils.js"],"sourcesContent":["import {\r\n\tGPUTextureAspect, GPUTextureViewDimension\r\n} from './WebGPUConstants.js';\r\n\r\nclass WebGPUBindingUtils {\r\n\r\n\tconstructor( backend ) {\r\n\r\n\t\tthis.backend = backend;\r\n\r\n\t}\r\n\r\n\tcreateBindings( bindings, pipeline ) {\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst bindingsData = backend.get( bindings );\r\n\r\n\t\t// setup (static) binding layout and (dynamic) binding group\r\n\r\n\t\tconst pipelineGPU = backend.get( pipeline ).pipeline;\r\n\r\n\t\tconst bindLayoutGPU = pipelineGPU.getBindGroupLayout( 0 );\r\n\t\tconst bindGroupGPU = this.createBindGroup( bindings, bindLayoutGPU );\r\n\r\n\t\tbindingsData.layout = bindLayoutGPU;\r\n\t\tbindingsData.group = bindGroupGPU;\r\n\t\tbindingsData.bindings = bindings;\r\n\r\n\t}\r\n\r\n\tupdateBinding( binding ) {\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst device = backend.device;\r\n\r\n\t\tconst buffer = binding.buffer;\r\n\t\tconst bufferGPU = backend.get( binding ).buffer;\r\n\r\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\r\n\r\n\t}\r\n\r\n\tcreateBindGroup( bindings, layoutGPU ) {\r\n\r\n\t\tconst backend = this.backend;\r\n\t\tconst device = backend.device;\r\n\r\n\t\tlet bindingPoint = 0;\r\n\t\tconst entriesGPU = [];\r\n\r\n\t\tfor ( const binding of bindings ) {\r\n\r\n\t\t\tif ( binding.isUniformBuffer ) {\r\n\r\n\t\t\t\tconst bindingData = backend.get( binding );\r\n\r\n\t\t\t\tif ( bindingData.buffer === undefined ) {\r\n\r\n\t\t\t\t\tconst byteLength = binding.byteLength;\r\n\r\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\r\n\r\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\r\n\t\t\t\t\t\tlabel: 'bindingBuffer',\r\n\t\t\t\t\t\tsize: byteLength,\r\n\t\t\t\t\t\tusage: usage\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tbindingData.buffer = bufferGPU;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\r\n\r\n\t\t\t} else if ( binding.isStorageBuffer ) {\r\n\r\n\t\t\t\tconst bindingData = backend.get( binding );\r\n\r\n\t\t\t\tif ( bindingData.buffer === undefined ) {\r\n\r\n\t\t\t\t\tconst attribute = binding.attribute;\r\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\r\n\r\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\r\n\r\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\r\n\r\n\t\t\t} else if ( binding.isSampler ) {\r\n\r\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\r\n\r\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\r\n\r\n\t\t\t} else if ( binding.isSampledTexture ) {\r\n\r\n\t\t\t\tconst textureData = backend.get( binding.texture );\r\n\r\n\t\t\t\tlet dimensionViewGPU;\r\n\r\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\r\n\r\n\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet resourceGPU;\r\n\r\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\r\n\r\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\r\n\r\n\t\t\t\t\tresourceGPU = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU } );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingPoint ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn device.createBindGroup( {\r\n\t\t\tlayout: layoutGPU,\r\n\t\t\tentries: entriesGPU\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WebGPUBindingUtils;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}